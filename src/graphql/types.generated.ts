// eslint-disable
// ⚠️ DO NOT EDIT ⚠️
// This file is automatically generated, run yarn run generate to update

import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'
export type Maybe<T> = T | null
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
const defaultOptions = {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
}

export type Ama = {
  __typename?: 'AMA'
  author?: Maybe<User>
  comments: Array<Maybe<Comment>>
  createdAt: Scalars['String']
  id: Scalars['String']
  text?: Maybe<Scalars['String']>
  updatedAt?: Maybe<Scalars['String']>
}

export enum AmaStatus {
  Answered = 'ANSWERED',
  Pending = 'PENDING',
}

export type Bookmark = {
  __typename?: 'Bookmark'
  comments: Array<Maybe<Comment>>
  createdAt: Scalars['String']
  description?: Maybe<Scalars['String']>
  host: Scalars['String']
  id: Scalars['ID']
  image?: Maybe<Scalars['String']>
  siteName?: Maybe<Scalars['String']>
  title?: Maybe<Scalars['String']>
  updatedAt: Scalars['String']
  url: Scalars['String']
}

export type Comment = {
  __typename?: 'Comment'
  author: User
  createdAt: Scalars['String']
  id: Scalars['ID']
  text?: Maybe<Scalars['String']>
  updatedAt?: Maybe<Scalars['String']>
  viewerCanDelete?: Maybe<Scalars['Boolean']>
  viewerCanEdit?: Maybe<Scalars['Boolean']>
}

export enum CommentType {
  Bookmark = 'BOOKMARK',
  Post = 'POST',
  Question = 'QUESTION',
  Stack = 'STACK',
}

export type EditUserInput = {
  email?: Maybe<Scalars['String']>
  username?: Maybe<Scalars['String']>
}

export type Episode = {
  __typename?: 'Episode'
  description?: Maybe<Scalars['String']>
  id?: Maybe<Scalars['String']>
  legacy_id?: Maybe<Scalars['String']>
  long_description?: Maybe<Scalars['String']>
  published_at?: Maybe<Scalars['String']>
  status?: Maybe<Scalars['String']>
  title?: Maybe<Scalars['String']>
  token?: Maybe<Scalars['String']>
}

export type Mutation = {
  __typename?: 'Mutation'
  addAMAAudioPlay?: Maybe<Scalars['Boolean']>
  addAMAQuestion?: Maybe<Scalars['Boolean']>
  addAMAReaction?: Maybe<Ama>
  addBookmark?: Maybe<Bookmark>
  addBookmarkReaction?: Maybe<Bookmark>
  addComment?: Maybe<Comment>
  deleteAMAQuestion?: Maybe<Scalars['Boolean']>
  deleteBookmark?: Maybe<Scalars['Boolean']>
  deleteComment?: Maybe<Scalars['Boolean']>
  deleteUser?: Maybe<Scalars['Boolean']>
  editAMAQuestion?: Maybe<Ama>
  editBookmark?: Maybe<Bookmark>
  editComment?: Maybe<Comment>
  editUser?: Maybe<User>
  transcribeAudio?: Maybe<Scalars['String']>
}

export type MutationAddAmaAudioPlayArgs = {
  id: Scalars['ID']
}

export type MutationAddAmaQuestionArgs = {
  text: Scalars['String']
}

export type MutationAddAmaReactionArgs = {
  id: Scalars['ID']
}

export type MutationAddBookmarkArgs = {
  url: Scalars['String']
}

export type MutationAddBookmarkReactionArgs = {
  id: Scalars['ID']
}

export type MutationAddCommentArgs = {
  refId: Scalars['String']
  text: Scalars['String']
  type: CommentType
}

export type MutationDeleteAmaQuestionArgs = {
  id: Scalars['ID']
}

export type MutationDeleteBookmarkArgs = {
  id: Scalars['ID']
}

export type MutationDeleteCommentArgs = {
  id: Scalars['ID']
}

export type MutationEditAmaQuestionArgs = {
  answer?: Maybe<Scalars['String']>
  audioWaveform?: Maybe<Array<Maybe<Scalars['Float']>>>
  id: Scalars['ID']
  question?: Maybe<Scalars['String']>
  status?: Maybe<AmaStatus>
}

export type MutationEditBookmarkArgs = {
  id: Scalars['ID']
  title: Scalars['String']
}

export type MutationEditCommentArgs = {
  id: Scalars['ID']
  text?: Maybe<Scalars['String']>
}

export type MutationEditUserArgs = {
  data?: Maybe<EditUserInput>
}

export type MutationTranscribeAudioArgs = {
  url: Scalars['String']
}

export type Post = {
  __typename?: 'Post'
  canonical_url?: Maybe<Scalars['String']>
  comment_id?: Maybe<Scalars['String']>
  created_at?: Maybe<Scalars['String']>
  custom_excerpt?: Maybe<Scalars['String']>
  excerpt?: Maybe<Scalars['String']>
  feature_image?: Maybe<Scalars['String']>
  featured?: Maybe<Scalars['Boolean']>
  html?: Maybe<Scalars['String']>
  id?: Maybe<Scalars['String']>
  meta_description?: Maybe<Scalars['String']>
  meta_title?: Maybe<Scalars['String']>
  og_description?: Maybe<Scalars['String']>
  og_image?: Maybe<Scalars['String']>
  og_title?: Maybe<Scalars['String']>
  published_at?: Maybe<Scalars['String']>
  reading_time?: Maybe<Scalars['Int']>
  slug?: Maybe<Scalars['String']>
  title?: Maybe<Scalars['String']>
  twitter_description?: Maybe<Scalars['String']>
  twitter_image?: Maybe<Scalars['String']>
  twitter_title?: Maybe<Scalars['String']>
  updated_at?: Maybe<Scalars['String']>
  url?: Maybe<Scalars['String']>
  uuid?: Maybe<Scalars['String']>
  visibility?: Maybe<Scalars['String']>
}

export type Query = {
  __typename?: 'Query'
  amaQuestion?: Maybe<Ama>
  amaQuestions: Array<Maybe<Ama>>
  bookmark?: Maybe<Bookmark>
  bookmarks: Array<Maybe<Bookmark>>
  comment?: Maybe<Comment>
  comments: Array<Maybe<Comment>>
  episodes: Array<Maybe<Episode>>
  post?: Maybe<Post>
  posts: Array<Maybe<Post>>
  repos: Array<Maybe<Repo>>
  signedPlaybackUrl?: Maybe<Scalars['String']>
  signedUploadUrl?: Maybe<Scalars['String']>
  transcription?: Maybe<Scalars['String']>
  user?: Maybe<User>
  viewer?: Maybe<User>
}

export type QueryAmaQuestionArgs = {
  id: Scalars['ID']
}

export type QueryAmaQuestionsArgs = {
  skip?: Maybe<Scalars['Int']>
  status?: Maybe<AmaStatus>
}

export type QueryBookmarkArgs = {
  id: Scalars['ID']
}

export type QueryBookmarksArgs = {
  skip?: Maybe<Scalars['Int']>
}

export type QueryCommentArgs = {
  id: Scalars['ID']
}

export type QueryCommentsArgs = {
  refId?: Maybe<Scalars['String']>
  type?: Maybe<CommentType>
}

export type QueryPostArgs = {
  slug: Scalars['String']
}

export type QueryPostsArgs = {
  filter?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  order?: Maybe<Scalars['String']>
}

export type QuerySignedPlaybackUrlArgs = {
  id: Scalars['ID']
}

export type QuerySignedUploadUrlArgs = {
  id: Scalars['ID']
}

export type QueryTranscriptionArgs = {
  transcriptionId: Scalars['ID']
}

export type QueryUserArgs = {
  username: Scalars['String']
}

export type Repo = {
  __typename?: 'Repo'
  description?: Maybe<Scalars['String']>
  name?: Maybe<Scalars['String']>
  org?: Maybe<Scalars['String']>
  stars?: Maybe<Scalars['Int']>
}

export type User = {
  __typename?: 'User'
  avatar?: Maybe<Scalars['String']>
  createdAt?: Maybe<Scalars['String']>
  email?: Maybe<Scalars['String']>
  id: Scalars['ID']
  isViewer?: Maybe<Scalars['Boolean']>
  name?: Maybe<Scalars['String']>
  pendingEmail?: Maybe<Scalars['String']>
  role?: Maybe<UserRole>
  username?: Maybe<Scalars['String']>
}

export enum UserRole {
  Admin = 'ADMIN',
  Blocked = 'BLOCKED',
  User = 'USER',
}

export type AmaInfoFragment = {
  __typename?: 'AMA'
  id: string
  createdAt: string
  updatedAt?: string | null | undefined
  text?: string | null | undefined
  author?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isViewer?: boolean | null | undefined
        email?: string | null | undefined
        pendingEmail?: string | null | undefined
      }
    | null
    | undefined
  comments: Array<
    | {
        __typename: 'Comment'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        text?: string | null | undefined
        viewerCanEdit?: boolean | null | undefined
        viewerCanDelete?: boolean | null | undefined
        author: {
          __typename: 'User'
          id: string
          username?: string | null | undefined
          avatar?: string | null | undefined
          name?: string | null | undefined
          role?: UserRole | null | undefined
          isViewer?: boolean | null | undefined
          email?: string | null | undefined
          pendingEmail?: string | null | undefined
        }
      }
    | null
    | undefined
  >
}

export type BookmarkInfoFragment = {
  __typename: 'Bookmark'
  id: string
  createdAt: string
  url: string
  host: string
  title?: string | null | undefined
  image?: string | null | undefined
  siteName?: string | null | undefined
  description?: string | null | undefined
}

export type CommentInfoFragment = {
  __typename: 'Comment'
  id: string
  createdAt: string
  updatedAt?: string | null | undefined
  text?: string | null | undefined
  viewerCanEdit?: boolean | null | undefined
  viewerCanDelete?: boolean | null | undefined
  author: {
    __typename: 'User'
    id: string
    username?: string | null | undefined
    avatar?: string | null | undefined
    name?: string | null | undefined
    role?: UserRole | null | undefined
    isViewer?: boolean | null | undefined
    email?: string | null | undefined
    pendingEmail?: string | null | undefined
  }
}

export type EpisodeInfoFragment = {
  __typename?: 'Episode'
  id?: string | null | undefined
  description?: string | null | undefined
  legacy_id?: string | null | undefined
  long_description?: string | null | undefined
  published_at?: string | null | undefined
  status?: string | null | undefined
  title?: string | null | undefined
  token?: string | null | undefined
}

export type PostInfoFragment = {
  __typename?: 'Post'
  id?: string | null | undefined
  title?: string | null | undefined
  slug?: string | null | undefined
  updated_at?: string | null | undefined
  published_at?: string | null | undefined
  excerpt?: string | null | undefined
  feature_image?: string | null | undefined
  html?: string | null | undefined
}

export type RepoInfoFragment = {
  __typename?: 'Repo'
  org?: string | null | undefined
  name?: string | null | undefined
  description?: string | null | undefined
  stars?: number | null | undefined
}

export type UserInfoFragment = {
  __typename: 'User'
  id: string
  username?: string | null | undefined
  avatar?: string | null | undefined
  name?: string | null | undefined
  role?: UserRole | null | undefined
  isViewer?: boolean | null | undefined
  email?: string | null | undefined
  pendingEmail?: string | null | undefined
}

export type EditAmaQuestionMutationVariables = Exact<{
  id: Scalars['ID']
  question: Scalars['String']
  answer: Scalars['String']
  status: AmaStatus
  audioWaveform?: Maybe<
    Array<Maybe<Scalars['Float']>> | Maybe<Scalars['Float']>
  >
}>

export type EditAmaQuestionMutation = {
  __typename?: 'Mutation'
  editAMAQuestion?:
    | {
        __typename?: 'AMA'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        text?: string | null | undefined
        author?:
          | {
              __typename: 'User'
              id: string
              username?: string | null | undefined
              avatar?: string | null | undefined
              name?: string | null | undefined
              role?: UserRole | null | undefined
              isViewer?: boolean | null | undefined
              email?: string | null | undefined
              pendingEmail?: string | null | undefined
            }
          | null
          | undefined
        comments: Array<
          | {
              __typename: 'Comment'
              id: string
              createdAt: string
              updatedAt?: string | null | undefined
              text?: string | null | undefined
              viewerCanEdit?: boolean | null | undefined
              viewerCanDelete?: boolean | null | undefined
              author: {
                __typename: 'User'
                id: string
                username?: string | null | undefined
                avatar?: string | null | undefined
                name?: string | null | undefined
                role?: UserRole | null | undefined
                isViewer?: boolean | null | undefined
                email?: string | null | undefined
                pendingEmail?: string | null | undefined
              }
            }
          | null
          | undefined
        >
      }
    | null
    | undefined
}

export type DeleteAmaQuestionMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type DeleteAmaQuestionMutation = {
  __typename?: 'Mutation'
  deleteAMAQuestion?: boolean | null | undefined
}

export type AddAmaQuestionMutationVariables = Exact<{
  text: Scalars['String']
}>

export type AddAmaQuestionMutation = {
  __typename?: 'Mutation'
  addAMAQuestion?: boolean | null | undefined
}

export type AddAmaReactionMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type AddAmaReactionMutation = {
  __typename?: 'Mutation'
  addAMAReaction?:
    | {
        __typename?: 'AMA'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        text?: string | null | undefined
        author?:
          | {
              __typename: 'User'
              id: string
              username?: string | null | undefined
              avatar?: string | null | undefined
              name?: string | null | undefined
              role?: UserRole | null | undefined
              isViewer?: boolean | null | undefined
              email?: string | null | undefined
              pendingEmail?: string | null | undefined
            }
          | null
          | undefined
        comments: Array<
          | {
              __typename: 'Comment'
              id: string
              createdAt: string
              updatedAt?: string | null | undefined
              text?: string | null | undefined
              viewerCanEdit?: boolean | null | undefined
              viewerCanDelete?: boolean | null | undefined
              author: {
                __typename: 'User'
                id: string
                username?: string | null | undefined
                avatar?: string | null | undefined
                name?: string | null | undefined
                role?: UserRole | null | undefined
                isViewer?: boolean | null | undefined
                email?: string | null | undefined
                pendingEmail?: string | null | undefined
              }
            }
          | null
          | undefined
        >
      }
    | null
    | undefined
}

export type AddAmaAudioPlayMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type AddAmaAudioPlayMutation = {
  __typename?: 'Mutation'
  addAMAAudioPlay?: boolean | null | undefined
}

export type TranscribeAudioMutationVariables = Exact<{
  url: Scalars['String']
}>

export type TranscribeAudioMutation = {
  __typename?: 'Mutation'
  transcribeAudio?: string | null | undefined
}

export type EditBookmarkMutationVariables = Exact<{
  id: Scalars['ID']
  title: Scalars['String']
}>

export type EditBookmarkMutation = {
  __typename?: 'Mutation'
  editBookmark?:
    | {
        __typename: 'Bookmark'
        id: string
        createdAt: string
        url: string
        host: string
        title?: string | null | undefined
        image?: string | null | undefined
        siteName?: string | null | undefined
        description?: string | null | undefined
      }
    | null
    | undefined
}

export type DeleteBookmarkMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type DeleteBookmarkMutation = {
  __typename?: 'Mutation'
  deleteBookmark?: boolean | null | undefined
}

export type AddBookmarkMutationVariables = Exact<{
  url: Scalars['String']
}>

export type AddBookmarkMutation = {
  __typename?: 'Mutation'
  addBookmark?:
    | {
        __typename: 'Bookmark'
        id: string
        createdAt: string
        url: string
        host: string
        title?: string | null | undefined
        image?: string | null | undefined
        siteName?: string | null | undefined
        description?: string | null | undefined
      }
    | null
    | undefined
}

export type AddBookmarkReactionMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type AddBookmarkReactionMutation = {
  __typename?: 'Mutation'
  addBookmarkReaction?:
    | {
        __typename: 'Bookmark'
        id: string
        createdAt: string
        url: string
        host: string
        title?: string | null | undefined
        image?: string | null | undefined
        siteName?: string | null | undefined
        description?: string | null | undefined
      }
    | null
    | undefined
}

export type AddCommentMutationVariables = Exact<{
  refId: Scalars['String']
  type: CommentType
  text: Scalars['String']
}>

export type AddCommentMutation = {
  __typename?: 'Mutation'
  addComment?:
    | {
        __typename: 'Comment'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        text?: string | null | undefined
        viewerCanEdit?: boolean | null | undefined
        viewerCanDelete?: boolean | null | undefined
        author: {
          __typename: 'User'
          id: string
          username?: string | null | undefined
          avatar?: string | null | undefined
          name?: string | null | undefined
          role?: UserRole | null | undefined
          isViewer?: boolean | null | undefined
          email?: string | null | undefined
          pendingEmail?: string | null | undefined
        }
      }
    | null
    | undefined
}

export type EditCommentMutationVariables = Exact<{
  id: Scalars['ID']
  text: Scalars['String']
}>

export type EditCommentMutation = {
  __typename?: 'Mutation'
  editComment?:
    | {
        __typename: 'Comment'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        text?: string | null | undefined
        viewerCanEdit?: boolean | null | undefined
        viewerCanDelete?: boolean | null | undefined
        author: {
          __typename: 'User'
          id: string
          username?: string | null | undefined
          avatar?: string | null | undefined
          name?: string | null | undefined
          role?: UserRole | null | undefined
          isViewer?: boolean | null | undefined
          email?: string | null | undefined
          pendingEmail?: string | null | undefined
        }
      }
    | null
    | undefined
}

export type DeleteCommentMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type DeleteCommentMutation = {
  __typename?: 'Mutation'
  deleteComment?: boolean | null | undefined
}

export type DeleteUserMutationVariables = Exact<{ [key: string]: never }>

export type DeleteUserMutation = {
  __typename?: 'Mutation'
  deleteUser?: boolean | null | undefined
}

export type EditUserMutationVariables = Exact<{
  data?: Maybe<EditUserInput>
}>

export type EditUserMutation = {
  __typename?: 'Mutation'
  editUser?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isViewer?: boolean | null | undefined
        email?: string | null | undefined
        pendingEmail?: string | null | undefined
      }
    | null
    | undefined
}

export type GetAmaQuestionsQueryVariables = Exact<{
  skip?: Maybe<Scalars['Int']>
  status?: Maybe<AmaStatus>
}>

export type GetAmaQuestionsQuery = {
  __typename?: 'Query'
  amaQuestions: Array<
    | {
        __typename?: 'AMA'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        text?: string | null | undefined
        author?:
          | {
              __typename: 'User'
              id: string
              username?: string | null | undefined
              avatar?: string | null | undefined
              name?: string | null | undefined
              role?: UserRole | null | undefined
              isViewer?: boolean | null | undefined
              email?: string | null | undefined
              pendingEmail?: string | null | undefined
            }
          | null
          | undefined
        comments: Array<
          | {
              __typename: 'Comment'
              id: string
              createdAt: string
              updatedAt?: string | null | undefined
              text?: string | null | undefined
              viewerCanEdit?: boolean | null | undefined
              viewerCanDelete?: boolean | null | undefined
              author: {
                __typename: 'User'
                id: string
                username?: string | null | undefined
                avatar?: string | null | undefined
                name?: string | null | undefined
                role?: UserRole | null | undefined
                isViewer?: boolean | null | undefined
                email?: string | null | undefined
                pendingEmail?: string | null | undefined
              }
            }
          | null
          | undefined
        >
      }
    | null
    | undefined
  >
}

export type GetAmaQuestionQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type GetAmaQuestionQuery = {
  __typename?: 'Query'
  amaQuestion?:
    | {
        __typename?: 'AMA'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        text?: string | null | undefined
        author?:
          | {
              __typename: 'User'
              id: string
              username?: string | null | undefined
              avatar?: string | null | undefined
              name?: string | null | undefined
              role?: UserRole | null | undefined
              isViewer?: boolean | null | undefined
              email?: string | null | undefined
              pendingEmail?: string | null | undefined
            }
          | null
          | undefined
        comments: Array<
          | {
              __typename: 'Comment'
              id: string
              createdAt: string
              updatedAt?: string | null | undefined
              text?: string | null | undefined
              viewerCanEdit?: boolean | null | undefined
              viewerCanDelete?: boolean | null | undefined
              author: {
                __typename: 'User'
                id: string
                username?: string | null | undefined
                avatar?: string | null | undefined
                name?: string | null | undefined
                role?: UserRole | null | undefined
                isViewer?: boolean | null | undefined
                email?: string | null | undefined
                pendingEmail?: string | null | undefined
              }
            }
          | null
          | undefined
        >
      }
    | null
    | undefined
}

export type SignedUploadUrlQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type SignedUploadUrlQuery = {
  __typename?: 'Query'
  signedUploadUrl?: string | null | undefined
}

export type SignedPlaybackUrlQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type SignedPlaybackUrlQuery = {
  __typename?: 'Query'
  signedPlaybackUrl?: string | null | undefined
}

export type TranscriptionQueryVariables = Exact<{
  transcriptionId: Scalars['ID']
}>

export type TranscriptionQuery = {
  __typename?: 'Query'
  transcription?: string | null | undefined
}

export type GetBookmarksQueryVariables = Exact<{
  skip?: Maybe<Scalars['Int']>
}>

export type GetBookmarksQuery = {
  __typename?: 'Query'
  bookmarks: Array<
    | {
        __typename: 'Bookmark'
        id: string
        createdAt: string
        url: string
        host: string
        title?: string | null | undefined
        image?: string | null | undefined
        siteName?: string | null | undefined
        description?: string | null | undefined
      }
    | null
    | undefined
  >
}

export type GetBookmarkQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type GetBookmarkQuery = {
  __typename?: 'Query'
  bookmark?:
    | {
        __typename: 'Bookmark'
        id: string
        createdAt: string
        url: string
        host: string
        title?: string | null | undefined
        image?: string | null | undefined
        siteName?: string | null | undefined
        description?: string | null | undefined
      }
    | null
    | undefined
}

export type GetCommentsQueryVariables = Exact<{
  refId?: Maybe<Scalars['String']>
  type?: Maybe<CommentType>
}>

export type GetCommentsQuery = {
  __typename?: 'Query'
  comments: Array<
    | {
        __typename: 'Comment'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        text?: string | null | undefined
        viewerCanEdit?: boolean | null | undefined
        viewerCanDelete?: boolean | null | undefined
        author: {
          __typename: 'User'
          id: string
          username?: string | null | undefined
          avatar?: string | null | undefined
          name?: string | null | undefined
          role?: UserRole | null | undefined
          isViewer?: boolean | null | undefined
          email?: string | null | undefined
          pendingEmail?: string | null | undefined
        }
      }
    | null
    | undefined
  >
}

export type GetEpisodesQueryVariables = Exact<{ [key: string]: never }>

export type GetEpisodesQuery = {
  __typename?: 'Query'
  episodes: Array<
    | {
        __typename?: 'Episode'
        id?: string | null | undefined
        description?: string | null | undefined
        legacy_id?: string | null | undefined
        long_description?: string | null | undefined
        published_at?: string | null | undefined
        status?: string | null | undefined
        title?: string | null | undefined
        token?: string | null | undefined
      }
    | null
    | undefined
  >
}

export type GetHomeQueryVariables = Exact<{ [key: string]: never }>

export type GetHomeQuery = {
  __typename?: 'Query'
  recent: Array<
    | {
        __typename?: 'Post'
        id?: string | null | undefined
        title?: string | null | undefined
        slug?: string | null | undefined
        updated_at?: string | null | undefined
        published_at?: string | null | undefined
        excerpt?: string | null | undefined
        feature_image?: string | null | undefined
        html?: string | null | undefined
      }
    | null
    | undefined
  >
  popular: Array<
    | {
        __typename?: 'Post'
        id?: string | null | undefined
        title?: string | null | undefined
        slug?: string | null | undefined
        updated_at?: string | null | undefined
        published_at?: string | null | undefined
        excerpt?: string | null | undefined
        feature_image?: string | null | undefined
        html?: string | null | undefined
      }
    | null
    | undefined
  >
  episodes: Array<
    | {
        __typename?: 'Episode'
        id?: string | null | undefined
        description?: string | null | undefined
        legacy_id?: string | null | undefined
        long_description?: string | null | undefined
        published_at?: string | null | undefined
        status?: string | null | undefined
        title?: string | null | undefined
        token?: string | null | undefined
      }
    | null
    | undefined
  >
}

export type GetPostsQueryVariables = Exact<{ [key: string]: never }>

export type GetPostsQuery = {
  __typename?: 'Query'
  posts: Array<
    | {
        __typename?: 'Post'
        id?: string | null | undefined
        title?: string | null | undefined
        slug?: string | null | undefined
        updated_at?: string | null | undefined
        published_at?: string | null | undefined
        excerpt?: string | null | undefined
        feature_image?: string | null | undefined
        html?: string | null | undefined
      }
    | null
    | undefined
  >
}

export type GetPostQueryVariables = Exact<{
  slug: Scalars['String']
}>

export type GetPostQuery = {
  __typename?: 'Query'
  post?:
    | {
        __typename?: 'Post'
        id?: string | null | undefined
        title?: string | null | undefined
        slug?: string | null | undefined
        updated_at?: string | null | undefined
        published_at?: string | null | undefined
        excerpt?: string | null | undefined
        feature_image?: string | null | undefined
        html?: string | null | undefined
      }
    | null
    | undefined
}

export type GetUserQueryVariables = Exact<{
  username: Scalars['String']
}>

export type GetUserQuery = {
  __typename?: 'Query'
  user?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isViewer?: boolean | null | undefined
        email?: string | null | undefined
        pendingEmail?: string | null | undefined
      }
    | null
    | undefined
}

export type ViewerQueryVariables = Exact<{ [key: string]: never }>

export type ViewerQuery = {
  __typename?: 'Query'
  viewer?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isViewer?: boolean | null | undefined
        email?: string | null | undefined
        pendingEmail?: string | null | undefined
      }
    | null
    | undefined
}

export const UserInfoFragmentDoc = gql`
  fragment UserInfo on User {
    __typename
    id
    username
    avatar
    name
    role
    isViewer
    email
    pendingEmail
  }
`
export const CommentInfoFragmentDoc = gql`
  fragment CommentInfo on Comment {
    __typename
    id
    createdAt
    updatedAt
    text
    viewerCanEdit
    viewerCanDelete
    author {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`
export const AmaInfoFragmentDoc = gql`
  fragment AMAInfo on AMA {
    id
    createdAt
    updatedAt
    text
    author {
      ...UserInfo
    }
    comments {
      ...CommentInfo
    }
  }
  ${UserInfoFragmentDoc}
  ${CommentInfoFragmentDoc}
`
export const BookmarkInfoFragmentDoc = gql`
  fragment BookmarkInfo on Bookmark {
    __typename
    id
    createdAt
    url
    host
    title
    image
    siteName
    description
  }
`
export const EpisodeInfoFragmentDoc = gql`
  fragment EpisodeInfo on Episode {
    id
    description
    legacy_id
    long_description
    published_at
    status
    title
    token
  }
`
export const PostInfoFragmentDoc = gql`
  fragment PostInfo on Post {
    id
    title
    slug
    updated_at
    published_at
    excerpt
    feature_image
    html
  }
`
export const RepoInfoFragmentDoc = gql`
  fragment RepoInfo on Repo {
    org
    name
    description
    stars
  }
`
export const EditAmaQuestionDocument = gql`
  mutation editAMAQuestion(
    $id: ID!
    $question: String!
    $answer: String!
    $status: AMAStatus!
    $audioWaveform: [Float]
  ) {
    editAMAQuestion(
      id: $id
      question: $question
      answer: $answer
      status: $status
      audioWaveform: $audioWaveform
    ) {
      ...AMAInfo
    }
  }
  ${AmaInfoFragmentDoc}
`
export type EditAmaQuestionMutationFn = Apollo.MutationFunction<
  EditAmaQuestionMutation,
  EditAmaQuestionMutationVariables
>

/**
 * __useEditAmaQuestionMutation__
 *
 * To run a mutation, you first call `useEditAmaQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditAmaQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editAmaQuestionMutation, { data, loading, error }] = useEditAmaQuestionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      question: // value for 'question'
 *      answer: // value for 'answer'
 *      status: // value for 'status'
 *      audioWaveform: // value for 'audioWaveform'
 *   },
 * });
 */
export function useEditAmaQuestionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditAmaQuestionMutation,
    EditAmaQuestionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditAmaQuestionMutation,
    EditAmaQuestionMutationVariables
  >(EditAmaQuestionDocument, options)
}
export type EditAmaQuestionMutationHookResult = ReturnType<
  typeof useEditAmaQuestionMutation
>
export type EditAmaQuestionMutationResult =
  Apollo.MutationResult<EditAmaQuestionMutation>
export type EditAmaQuestionMutationOptions = Apollo.BaseMutationOptions<
  EditAmaQuestionMutation,
  EditAmaQuestionMutationVariables
>
export const DeleteAmaQuestionDocument = gql`
  mutation deleteAMAQuestion($id: ID!) {
    deleteAMAQuestion(id: $id)
  }
`
export type DeleteAmaQuestionMutationFn = Apollo.MutationFunction<
  DeleteAmaQuestionMutation,
  DeleteAmaQuestionMutationVariables
>

/**
 * __useDeleteAmaQuestionMutation__
 *
 * To run a mutation, you first call `useDeleteAmaQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAmaQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAmaQuestionMutation, { data, loading, error }] = useDeleteAmaQuestionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteAmaQuestionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteAmaQuestionMutation,
    DeleteAmaQuestionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeleteAmaQuestionMutation,
    DeleteAmaQuestionMutationVariables
  >(DeleteAmaQuestionDocument, options)
}
export type DeleteAmaQuestionMutationHookResult = ReturnType<
  typeof useDeleteAmaQuestionMutation
>
export type DeleteAmaQuestionMutationResult =
  Apollo.MutationResult<DeleteAmaQuestionMutation>
export type DeleteAmaQuestionMutationOptions = Apollo.BaseMutationOptions<
  DeleteAmaQuestionMutation,
  DeleteAmaQuestionMutationVariables
>
export const AddAmaQuestionDocument = gql`
  mutation addAMAQuestion($text: String!) {
    addAMAQuestion(text: $text)
  }
`
export type AddAmaQuestionMutationFn = Apollo.MutationFunction<
  AddAmaQuestionMutation,
  AddAmaQuestionMutationVariables
>

/**
 * __useAddAmaQuestionMutation__
 *
 * To run a mutation, you first call `useAddAmaQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddAmaQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addAmaQuestionMutation, { data, loading, error }] = useAddAmaQuestionMutation({
 *   variables: {
 *      text: // value for 'text'
 *   },
 * });
 */
export function useAddAmaQuestionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddAmaQuestionMutation,
    AddAmaQuestionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    AddAmaQuestionMutation,
    AddAmaQuestionMutationVariables
  >(AddAmaQuestionDocument, options)
}
export type AddAmaQuestionMutationHookResult = ReturnType<
  typeof useAddAmaQuestionMutation
>
export type AddAmaQuestionMutationResult =
  Apollo.MutationResult<AddAmaQuestionMutation>
export type AddAmaQuestionMutationOptions = Apollo.BaseMutationOptions<
  AddAmaQuestionMutation,
  AddAmaQuestionMutationVariables
>
export const AddAmaReactionDocument = gql`
  mutation addAMAReaction($id: ID!) {
    addAMAReaction(id: $id) {
      ...AMAInfo
    }
  }
  ${AmaInfoFragmentDoc}
`
export type AddAmaReactionMutationFn = Apollo.MutationFunction<
  AddAmaReactionMutation,
  AddAmaReactionMutationVariables
>

/**
 * __useAddAmaReactionMutation__
 *
 * To run a mutation, you first call `useAddAmaReactionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddAmaReactionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addAmaReactionMutation, { data, loading, error }] = useAddAmaReactionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useAddAmaReactionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddAmaReactionMutation,
    AddAmaReactionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    AddAmaReactionMutation,
    AddAmaReactionMutationVariables
  >(AddAmaReactionDocument, options)
}
export type AddAmaReactionMutationHookResult = ReturnType<
  typeof useAddAmaReactionMutation
>
export type AddAmaReactionMutationResult =
  Apollo.MutationResult<AddAmaReactionMutation>
export type AddAmaReactionMutationOptions = Apollo.BaseMutationOptions<
  AddAmaReactionMutation,
  AddAmaReactionMutationVariables
>
export const AddAmaAudioPlayDocument = gql`
  mutation addAMAAudioPlay($id: ID!) {
    addAMAAudioPlay(id: $id)
  }
`
export type AddAmaAudioPlayMutationFn = Apollo.MutationFunction<
  AddAmaAudioPlayMutation,
  AddAmaAudioPlayMutationVariables
>

/**
 * __useAddAmaAudioPlayMutation__
 *
 * To run a mutation, you first call `useAddAmaAudioPlayMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddAmaAudioPlayMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addAmaAudioPlayMutation, { data, loading, error }] = useAddAmaAudioPlayMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useAddAmaAudioPlayMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddAmaAudioPlayMutation,
    AddAmaAudioPlayMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    AddAmaAudioPlayMutation,
    AddAmaAudioPlayMutationVariables
  >(AddAmaAudioPlayDocument, options)
}
export type AddAmaAudioPlayMutationHookResult = ReturnType<
  typeof useAddAmaAudioPlayMutation
>
export type AddAmaAudioPlayMutationResult =
  Apollo.MutationResult<AddAmaAudioPlayMutation>
export type AddAmaAudioPlayMutationOptions = Apollo.BaseMutationOptions<
  AddAmaAudioPlayMutation,
  AddAmaAudioPlayMutationVariables
>
export const TranscribeAudioDocument = gql`
  mutation transcribeAudio($url: String!) {
    transcribeAudio(url: $url)
  }
`
export type TranscribeAudioMutationFn = Apollo.MutationFunction<
  TranscribeAudioMutation,
  TranscribeAudioMutationVariables
>

/**
 * __useTranscribeAudioMutation__
 *
 * To run a mutation, you first call `useTranscribeAudioMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTranscribeAudioMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [transcribeAudioMutation, { data, loading, error }] = useTranscribeAudioMutation({
 *   variables: {
 *      url: // value for 'url'
 *   },
 * });
 */
export function useTranscribeAudioMutation(
  baseOptions?: Apollo.MutationHookOptions<
    TranscribeAudioMutation,
    TranscribeAudioMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    TranscribeAudioMutation,
    TranscribeAudioMutationVariables
  >(TranscribeAudioDocument, options)
}
export type TranscribeAudioMutationHookResult = ReturnType<
  typeof useTranscribeAudioMutation
>
export type TranscribeAudioMutationResult =
  Apollo.MutationResult<TranscribeAudioMutation>
export type TranscribeAudioMutationOptions = Apollo.BaseMutationOptions<
  TranscribeAudioMutation,
  TranscribeAudioMutationVariables
>
export const EditBookmarkDocument = gql`
  mutation editBookmark($id: ID!, $title: String!) {
    editBookmark(id: $id, title: $title) {
      ...BookmarkInfo
    }
  }
  ${BookmarkInfoFragmentDoc}
`
export type EditBookmarkMutationFn = Apollo.MutationFunction<
  EditBookmarkMutation,
  EditBookmarkMutationVariables
>

/**
 * __useEditBookmarkMutation__
 *
 * To run a mutation, you first call `useEditBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editBookmarkMutation, { data, loading, error }] = useEditBookmarkMutation({
 *   variables: {
 *      id: // value for 'id'
 *      title: // value for 'title'
 *   },
 * });
 */
export function useEditBookmarkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditBookmarkMutation,
    EditBookmarkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditBookmarkMutation,
    EditBookmarkMutationVariables
  >(EditBookmarkDocument, options)
}
export type EditBookmarkMutationHookResult = ReturnType<
  typeof useEditBookmarkMutation
>
export type EditBookmarkMutationResult =
  Apollo.MutationResult<EditBookmarkMutation>
export type EditBookmarkMutationOptions = Apollo.BaseMutationOptions<
  EditBookmarkMutation,
  EditBookmarkMutationVariables
>
export const DeleteBookmarkDocument = gql`
  mutation deleteBookmark($id: ID!) {
    deleteBookmark(id: $id)
  }
`
export type DeleteBookmarkMutationFn = Apollo.MutationFunction<
  DeleteBookmarkMutation,
  DeleteBookmarkMutationVariables
>

/**
 * __useDeleteBookmarkMutation__
 *
 * To run a mutation, you first call `useDeleteBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBookmarkMutation, { data, loading, error }] = useDeleteBookmarkMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteBookmarkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteBookmarkMutation,
    DeleteBookmarkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeleteBookmarkMutation,
    DeleteBookmarkMutationVariables
  >(DeleteBookmarkDocument, options)
}
export type DeleteBookmarkMutationHookResult = ReturnType<
  typeof useDeleteBookmarkMutation
>
export type DeleteBookmarkMutationResult =
  Apollo.MutationResult<DeleteBookmarkMutation>
export type DeleteBookmarkMutationOptions = Apollo.BaseMutationOptions<
  DeleteBookmarkMutation,
  DeleteBookmarkMutationVariables
>
export const AddBookmarkDocument = gql`
  mutation addBookmark($url: String!) {
    addBookmark(url: $url) {
      ...BookmarkInfo
    }
  }
  ${BookmarkInfoFragmentDoc}
`
export type AddBookmarkMutationFn = Apollo.MutationFunction<
  AddBookmarkMutation,
  AddBookmarkMutationVariables
>

/**
 * __useAddBookmarkMutation__
 *
 * To run a mutation, you first call `useAddBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addBookmarkMutation, { data, loading, error }] = useAddBookmarkMutation({
 *   variables: {
 *      url: // value for 'url'
 *   },
 * });
 */
export function useAddBookmarkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddBookmarkMutation,
    AddBookmarkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddBookmarkMutation, AddBookmarkMutationVariables>(
    AddBookmarkDocument,
    options
  )
}
export type AddBookmarkMutationHookResult = ReturnType<
  typeof useAddBookmarkMutation
>
export type AddBookmarkMutationResult =
  Apollo.MutationResult<AddBookmarkMutation>
export type AddBookmarkMutationOptions = Apollo.BaseMutationOptions<
  AddBookmarkMutation,
  AddBookmarkMutationVariables
>
export const AddBookmarkReactionDocument = gql`
  mutation addBookmarkReaction($id: ID!) {
    addBookmarkReaction(id: $id) {
      ...BookmarkInfo
    }
  }
  ${BookmarkInfoFragmentDoc}
`
export type AddBookmarkReactionMutationFn = Apollo.MutationFunction<
  AddBookmarkReactionMutation,
  AddBookmarkReactionMutationVariables
>

/**
 * __useAddBookmarkReactionMutation__
 *
 * To run a mutation, you first call `useAddBookmarkReactionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddBookmarkReactionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addBookmarkReactionMutation, { data, loading, error }] = useAddBookmarkReactionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useAddBookmarkReactionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddBookmarkReactionMutation,
    AddBookmarkReactionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    AddBookmarkReactionMutation,
    AddBookmarkReactionMutationVariables
  >(AddBookmarkReactionDocument, options)
}
export type AddBookmarkReactionMutationHookResult = ReturnType<
  typeof useAddBookmarkReactionMutation
>
export type AddBookmarkReactionMutationResult =
  Apollo.MutationResult<AddBookmarkReactionMutation>
export type AddBookmarkReactionMutationOptions = Apollo.BaseMutationOptions<
  AddBookmarkReactionMutation,
  AddBookmarkReactionMutationVariables
>
export const AddCommentDocument = gql`
  mutation addComment($refId: String!, $type: CommentType!, $text: String!) {
    addComment(refId: $refId, type: $type, text: $text) {
      ...CommentInfo
    }
  }
  ${CommentInfoFragmentDoc}
`
export type AddCommentMutationFn = Apollo.MutationFunction<
  AddCommentMutation,
  AddCommentMutationVariables
>

/**
 * __useAddCommentMutation__
 *
 * To run a mutation, you first call `useAddCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCommentMutation, { data, loading, error }] = useAddCommentMutation({
 *   variables: {
 *      refId: // value for 'refId'
 *      type: // value for 'type'
 *      text: // value for 'text'
 *   },
 * });
 */
export function useAddCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddCommentMutation,
    AddCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddCommentMutation, AddCommentMutationVariables>(
    AddCommentDocument,
    options
  )
}
export type AddCommentMutationHookResult = ReturnType<
  typeof useAddCommentMutation
>
export type AddCommentMutationResult = Apollo.MutationResult<AddCommentMutation>
export type AddCommentMutationOptions = Apollo.BaseMutationOptions<
  AddCommentMutation,
  AddCommentMutationVariables
>
export const EditCommentDocument = gql`
  mutation editComment($id: ID!, $text: String!) {
    editComment(id: $id, text: $text) {
      ...CommentInfo
    }
  }
  ${CommentInfoFragmentDoc}
`
export type EditCommentMutationFn = Apollo.MutationFunction<
  EditCommentMutation,
  EditCommentMutationVariables
>

/**
 * __useEditCommentMutation__
 *
 * To run a mutation, you first call `useEditCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editCommentMutation, { data, loading, error }] = useEditCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *      text: // value for 'text'
 *   },
 * });
 */
export function useEditCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditCommentMutation,
    EditCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditCommentMutation, EditCommentMutationVariables>(
    EditCommentDocument,
    options
  )
}
export type EditCommentMutationHookResult = ReturnType<
  typeof useEditCommentMutation
>
export type EditCommentMutationResult =
  Apollo.MutationResult<EditCommentMutation>
export type EditCommentMutationOptions = Apollo.BaseMutationOptions<
  EditCommentMutation,
  EditCommentMutationVariables
>
export const DeleteCommentDocument = gql`
  mutation deleteComment($id: ID!) {
    deleteComment(id: $id)
  }
`
export type DeleteCommentMutationFn = Apollo.MutationFunction<
  DeleteCommentMutation,
  DeleteCommentMutationVariables
>

/**
 * __useDeleteCommentMutation__
 *
 * To run a mutation, you first call `useDeleteCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCommentMutation, { data, loading, error }] = useDeleteCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteCommentMutation,
    DeleteCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeleteCommentMutation,
    DeleteCommentMutationVariables
  >(DeleteCommentDocument, options)
}
export type DeleteCommentMutationHookResult = ReturnType<
  typeof useDeleteCommentMutation
>
export type DeleteCommentMutationResult =
  Apollo.MutationResult<DeleteCommentMutation>
export type DeleteCommentMutationOptions = Apollo.BaseMutationOptions<
  DeleteCommentMutation,
  DeleteCommentMutationVariables
>
export const DeleteUserDocument = gql`
  mutation deleteUser {
    deleteUser
  }
`
export type DeleteUserMutationFn = Apollo.MutationFunction<
  DeleteUserMutation,
  DeleteUserMutationVariables
>

/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *   },
 * });
 */
export function useDeleteUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteUserMutation,
    DeleteUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteUserMutation, DeleteUserMutationVariables>(
    DeleteUserDocument,
    options
  )
}
export type DeleteUserMutationHookResult = ReturnType<
  typeof useDeleteUserMutation
>
export type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>
export type DeleteUserMutationOptions = Apollo.BaseMutationOptions<
  DeleteUserMutation,
  DeleteUserMutationVariables
>
export const EditUserDocument = gql`
  mutation editUser($data: EditUserInput) {
    editUser(data: $data) {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`
export type EditUserMutationFn = Apollo.MutationFunction<
  EditUserMutation,
  EditUserMutationVariables
>

/**
 * __useEditUserMutation__
 *
 * To run a mutation, you first call `useEditUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editUserMutation, { data, loading, error }] = useEditUserMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditUserMutation,
    EditUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditUserMutation, EditUserMutationVariables>(
    EditUserDocument,
    options
  )
}
export type EditUserMutationHookResult = ReturnType<typeof useEditUserMutation>
export type EditUserMutationResult = Apollo.MutationResult<EditUserMutation>
export type EditUserMutationOptions = Apollo.BaseMutationOptions<
  EditUserMutation,
  EditUserMutationVariables
>
export const GetAmaQuestionsDocument = gql`
  query GetAMAQuestions($skip: Int, $status: AMAStatus) {
    amaQuestions(skip: $skip, status: $status) {
      ...AMAInfo
    }
  }
  ${AmaInfoFragmentDoc}
`

/**
 * __useGetAmaQuestionsQuery__
 *
 * To run a query within a React component, call `useGetAmaQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAmaQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAmaQuestionsQuery({
 *   variables: {
 *      skip: // value for 'skip'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useGetAmaQuestionsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetAmaQuestionsQuery,
    GetAmaQuestionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetAmaQuestionsQuery, GetAmaQuestionsQueryVariables>(
    GetAmaQuestionsDocument,
    options
  )
}
export function useGetAmaQuestionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetAmaQuestionsQuery,
    GetAmaQuestionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    GetAmaQuestionsQuery,
    GetAmaQuestionsQueryVariables
  >(GetAmaQuestionsDocument, options)
}
export type GetAmaQuestionsQueryHookResult = ReturnType<
  typeof useGetAmaQuestionsQuery
>
export type GetAmaQuestionsLazyQueryHookResult = ReturnType<
  typeof useGetAmaQuestionsLazyQuery
>
export type GetAmaQuestionsQueryResult = Apollo.QueryResult<
  GetAmaQuestionsQuery,
  GetAmaQuestionsQueryVariables
>
export const GetAmaQuestionDocument = gql`
  query GetAMAQuestion($id: ID!) {
    amaQuestion(id: $id) {
      ...AMAInfo
    }
  }
  ${AmaInfoFragmentDoc}
`

/**
 * __useGetAmaQuestionQuery__
 *
 * To run a query within a React component, call `useGetAmaQuestionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAmaQuestionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAmaQuestionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetAmaQuestionQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetAmaQuestionQuery,
    GetAmaQuestionQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetAmaQuestionQuery, GetAmaQuestionQueryVariables>(
    GetAmaQuestionDocument,
    options
  )
}
export function useGetAmaQuestionLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetAmaQuestionQuery,
    GetAmaQuestionQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetAmaQuestionQuery, GetAmaQuestionQueryVariables>(
    GetAmaQuestionDocument,
    options
  )
}
export type GetAmaQuestionQueryHookResult = ReturnType<
  typeof useGetAmaQuestionQuery
>
export type GetAmaQuestionLazyQueryHookResult = ReturnType<
  typeof useGetAmaQuestionLazyQuery
>
export type GetAmaQuestionQueryResult = Apollo.QueryResult<
  GetAmaQuestionQuery,
  GetAmaQuestionQueryVariables
>
export const SignedUploadUrlDocument = gql`
  query signedUploadUrl($id: ID!) {
    signedUploadUrl(id: $id)
  }
`

/**
 * __useSignedUploadUrlQuery__
 *
 * To run a query within a React component, call `useSignedUploadUrlQuery` and pass it any options that fit your needs.
 * When your component renders, `useSignedUploadUrlQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSignedUploadUrlQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSignedUploadUrlQuery(
  baseOptions: Apollo.QueryHookOptions<
    SignedUploadUrlQuery,
    SignedUploadUrlQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<SignedUploadUrlQuery, SignedUploadUrlQueryVariables>(
    SignedUploadUrlDocument,
    options
  )
}
export function useSignedUploadUrlLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SignedUploadUrlQuery,
    SignedUploadUrlQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    SignedUploadUrlQuery,
    SignedUploadUrlQueryVariables
  >(SignedUploadUrlDocument, options)
}
export type SignedUploadUrlQueryHookResult = ReturnType<
  typeof useSignedUploadUrlQuery
>
export type SignedUploadUrlLazyQueryHookResult = ReturnType<
  typeof useSignedUploadUrlLazyQuery
>
export type SignedUploadUrlQueryResult = Apollo.QueryResult<
  SignedUploadUrlQuery,
  SignedUploadUrlQueryVariables
>
export const SignedPlaybackUrlDocument = gql`
  query signedPlaybackUrl($id: ID!) {
    signedPlaybackUrl(id: $id)
  }
`

/**
 * __useSignedPlaybackUrlQuery__
 *
 * To run a query within a React component, call `useSignedPlaybackUrlQuery` and pass it any options that fit your needs.
 * When your component renders, `useSignedPlaybackUrlQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSignedPlaybackUrlQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSignedPlaybackUrlQuery(
  baseOptions: Apollo.QueryHookOptions<
    SignedPlaybackUrlQuery,
    SignedPlaybackUrlQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    SignedPlaybackUrlQuery,
    SignedPlaybackUrlQueryVariables
  >(SignedPlaybackUrlDocument, options)
}
export function useSignedPlaybackUrlLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SignedPlaybackUrlQuery,
    SignedPlaybackUrlQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    SignedPlaybackUrlQuery,
    SignedPlaybackUrlQueryVariables
  >(SignedPlaybackUrlDocument, options)
}
export type SignedPlaybackUrlQueryHookResult = ReturnType<
  typeof useSignedPlaybackUrlQuery
>
export type SignedPlaybackUrlLazyQueryHookResult = ReturnType<
  typeof useSignedPlaybackUrlLazyQuery
>
export type SignedPlaybackUrlQueryResult = Apollo.QueryResult<
  SignedPlaybackUrlQuery,
  SignedPlaybackUrlQueryVariables
>
export const TranscriptionDocument = gql`
  query transcription($transcriptionId: ID!) {
    transcription(transcriptionId: $transcriptionId)
  }
`

/**
 * __useTranscriptionQuery__
 *
 * To run a query within a React component, call `useTranscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useTranscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTranscriptionQuery({
 *   variables: {
 *      transcriptionId: // value for 'transcriptionId'
 *   },
 * });
 */
export function useTranscriptionQuery(
  baseOptions: Apollo.QueryHookOptions<
    TranscriptionQuery,
    TranscriptionQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<TranscriptionQuery, TranscriptionQueryVariables>(
    TranscriptionDocument,
    options
  )
}
export function useTranscriptionLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    TranscriptionQuery,
    TranscriptionQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<TranscriptionQuery, TranscriptionQueryVariables>(
    TranscriptionDocument,
    options
  )
}
export type TranscriptionQueryHookResult = ReturnType<
  typeof useTranscriptionQuery
>
export type TranscriptionLazyQueryHookResult = ReturnType<
  typeof useTranscriptionLazyQuery
>
export type TranscriptionQueryResult = Apollo.QueryResult<
  TranscriptionQuery,
  TranscriptionQueryVariables
>
export const GetBookmarksDocument = gql`
  query GetBookmarks($skip: Int) {
    bookmarks(skip: $skip) {
      ...BookmarkInfo
    }
  }
  ${BookmarkInfoFragmentDoc}
`

/**
 * __useGetBookmarksQuery__
 *
 * To run a query within a React component, call `useGetBookmarksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBookmarksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBookmarksQuery({
 *   variables: {
 *      skip: // value for 'skip'
 *   },
 * });
 */
export function useGetBookmarksQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetBookmarksQuery,
    GetBookmarksQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBookmarksQuery, GetBookmarksQueryVariables>(
    GetBookmarksDocument,
    options
  )
}
export function useGetBookmarksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetBookmarksQuery,
    GetBookmarksQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBookmarksQuery, GetBookmarksQueryVariables>(
    GetBookmarksDocument,
    options
  )
}
export type GetBookmarksQueryHookResult = ReturnType<
  typeof useGetBookmarksQuery
>
export type GetBookmarksLazyQueryHookResult = ReturnType<
  typeof useGetBookmarksLazyQuery
>
export type GetBookmarksQueryResult = Apollo.QueryResult<
  GetBookmarksQuery,
  GetBookmarksQueryVariables
>
export const GetBookmarkDocument = gql`
  query GetBookmark($id: ID!) {
    bookmark(id: $id) {
      ...BookmarkInfo
    }
  }
  ${BookmarkInfoFragmentDoc}
`

/**
 * __useGetBookmarkQuery__
 *
 * To run a query within a React component, call `useGetBookmarkQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBookmarkQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBookmarkQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBookmarkQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetBookmarkQuery,
    GetBookmarkQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBookmarkQuery, GetBookmarkQueryVariables>(
    GetBookmarkDocument,
    options
  )
}
export function useGetBookmarkLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetBookmarkQuery,
    GetBookmarkQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBookmarkQuery, GetBookmarkQueryVariables>(
    GetBookmarkDocument,
    options
  )
}
export type GetBookmarkQueryHookResult = ReturnType<typeof useGetBookmarkQuery>
export type GetBookmarkLazyQueryHookResult = ReturnType<
  typeof useGetBookmarkLazyQuery
>
export type GetBookmarkQueryResult = Apollo.QueryResult<
  GetBookmarkQuery,
  GetBookmarkQueryVariables
>
export const GetCommentsDocument = gql`
  query getComments($refId: String, $type: CommentType) {
    comments(refId: $refId, type: $type) {
      ...CommentInfo
    }
  }
  ${CommentInfoFragmentDoc}
`

/**
 * __useGetCommentsQuery__
 *
 * To run a query within a React component, call `useGetCommentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCommentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCommentsQuery({
 *   variables: {
 *      refId: // value for 'refId'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetCommentsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetCommentsQuery,
    GetCommentsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetCommentsQuery, GetCommentsQueryVariables>(
    GetCommentsDocument,
    options
  )
}
export function useGetCommentsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetCommentsQuery,
    GetCommentsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetCommentsQuery, GetCommentsQueryVariables>(
    GetCommentsDocument,
    options
  )
}
export type GetCommentsQueryHookResult = ReturnType<typeof useGetCommentsQuery>
export type GetCommentsLazyQueryHookResult = ReturnType<
  typeof useGetCommentsLazyQuery
>
export type GetCommentsQueryResult = Apollo.QueryResult<
  GetCommentsQuery,
  GetCommentsQueryVariables
>
export const GetEpisodesDocument = gql`
  query GetEpisodes {
    episodes {
      ...EpisodeInfo
    }
  }
  ${EpisodeInfoFragmentDoc}
`

/**
 * __useGetEpisodesQuery__
 *
 * To run a query within a React component, call `useGetEpisodesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEpisodesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEpisodesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetEpisodesQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetEpisodesQuery,
    GetEpisodesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetEpisodesQuery, GetEpisodesQueryVariables>(
    GetEpisodesDocument,
    options
  )
}
export function useGetEpisodesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetEpisodesQuery,
    GetEpisodesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetEpisodesQuery, GetEpisodesQueryVariables>(
    GetEpisodesDocument,
    options
  )
}
export type GetEpisodesQueryHookResult = ReturnType<typeof useGetEpisodesQuery>
export type GetEpisodesLazyQueryHookResult = ReturnType<
  typeof useGetEpisodesLazyQuery
>
export type GetEpisodesQueryResult = Apollo.QueryResult<
  GetEpisodesQuery,
  GetEpisodesQueryVariables
>
export const GetHomeDocument = gql`
  query GetHome {
    recent: posts(first: 12) {
      ...PostInfo
    }
    popular: posts(
      first: 12
      filter: "tag:popular"
      order: "published_at ASC"
    ) {
      ...PostInfo
    }
    episodes {
      ...EpisodeInfo
    }
  }
  ${PostInfoFragmentDoc}
  ${EpisodeInfoFragmentDoc}
`

/**
 * __useGetHomeQuery__
 *
 * To run a query within a React component, call `useGetHomeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetHomeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetHomeQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetHomeQuery(
  baseOptions?: Apollo.QueryHookOptions<GetHomeQuery, GetHomeQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetHomeQuery, GetHomeQueryVariables>(
    GetHomeDocument,
    options
  )
}
export function useGetHomeLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetHomeQuery, GetHomeQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetHomeQuery, GetHomeQueryVariables>(
    GetHomeDocument,
    options
  )
}
export type GetHomeQueryHookResult = ReturnType<typeof useGetHomeQuery>
export type GetHomeLazyQueryHookResult = ReturnType<typeof useGetHomeLazyQuery>
export type GetHomeQueryResult = Apollo.QueryResult<
  GetHomeQuery,
  GetHomeQueryVariables
>
export const GetPostsDocument = gql`
  query GetPosts {
    posts {
      ...PostInfo
    }
  }
  ${PostInfoFragmentDoc}
`

/**
 * __useGetPostsQuery__
 *
 * To run a query within a React component, call `useGetPostsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPostsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPostsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetPostsQuery, GetPostsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPostsQuery, GetPostsQueryVariables>(
    GetPostsDocument,
    options
  )
}
export function useGetPostsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetPostsQuery,
    GetPostsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPostsQuery, GetPostsQueryVariables>(
    GetPostsDocument,
    options
  )
}
export type GetPostsQueryHookResult = ReturnType<typeof useGetPostsQuery>
export type GetPostsLazyQueryHookResult = ReturnType<
  typeof useGetPostsLazyQuery
>
export type GetPostsQueryResult = Apollo.QueryResult<
  GetPostsQuery,
  GetPostsQueryVariables
>
export const GetPostDocument = gql`
  query GetPost($slug: String!) {
    post(slug: $slug) {
      ...PostInfo
    }
  }
  ${PostInfoFragmentDoc}
`

/**
 * __useGetPostQuery__
 *
 * To run a query within a React component, call `useGetPostQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPostQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useGetPostQuery(
  baseOptions: Apollo.QueryHookOptions<GetPostQuery, GetPostQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPostQuery, GetPostQueryVariables>(
    GetPostDocument,
    options
  )
}
export function useGetPostLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetPostQuery, GetPostQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPostQuery, GetPostQueryVariables>(
    GetPostDocument,
    options
  )
}
export type GetPostQueryHookResult = ReturnType<typeof useGetPostQuery>
export type GetPostLazyQueryHookResult = ReturnType<typeof useGetPostLazyQuery>
export type GetPostQueryResult = Apollo.QueryResult<
  GetPostQuery,
  GetPostQueryVariables
>
export const GetUserDocument = gql`
  query getUser($username: String!) {
    user(username: $username) {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`

/**
 * __useGetUserQuery__
 *
 * To run a query within a React component, call `useGetUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserQuery({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useGetUserQuery(
  baseOptions: Apollo.QueryHookOptions<GetUserQuery, GetUserQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    options
  )
}
export function useGetUserLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetUserQuery, GetUserQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    options
  )
}
export type GetUserQueryHookResult = ReturnType<typeof useGetUserQuery>
export type GetUserLazyQueryHookResult = ReturnType<typeof useGetUserLazyQuery>
export type GetUserQueryResult = Apollo.QueryResult<
  GetUserQuery,
  GetUserQueryVariables
>
export const ViewerDocument = gql`
  query viewer {
    viewer {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`

/**
 * __useViewerQuery__
 *
 * To run a query within a React component, call `useViewerQuery` and pass it any options that fit your needs.
 * When your component renders, `useViewerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useViewerQuery({
 *   variables: {
 *   },
 * });
 */
export function useViewerQuery(
  baseOptions?: Apollo.QueryHookOptions<ViewerQuery, ViewerQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<ViewerQuery, ViewerQueryVariables>(
    ViewerDocument,
    options
  )
}
export function useViewerLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<ViewerQuery, ViewerQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<ViewerQuery, ViewerQueryVariables>(
    ViewerDocument,
    options
  )
}
export type ViewerQueryHookResult = ReturnType<typeof useViewerQuery>
export type ViewerLazyQueryHookResult = ReturnType<typeof useViewerLazyQuery>
export type ViewerQueryResult = Apollo.QueryResult<
  ViewerQuery,
  ViewerQueryVariables
>
