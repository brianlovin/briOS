// eslint-disable
// ⚠️ DO NOT EDIT ⚠️
// This file is automatically generated, run yarn run generate to update

import { gql } from '@apollo/client'
import * as Apollo from '@apollo/client'
export type Maybe<T> = T | null
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
const defaultOptions = {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
}

export type AddBookmarkInput = {
  tag: Scalars['String']
  url: Scalars['String']
}

export type AddQuestionInput = {
  description?: Maybe<Scalars['String']>
  title: Scalars['String']
}

export type AddStackInput = {
  description: Scalars['String']
  image: Scalars['String']
  name: Scalars['String']
  tag?: Maybe<Scalars['String']>
  url: Scalars['String']
}

export type Bookmark = {
  __typename?: 'Bookmark'
  createdAt: Scalars['String']
  description?: Maybe<Scalars['String']>
  faviconUrl?: Maybe<Scalars['String']>
  host: Scalars['String']
  id: Scalars['ID']
  image?: Maybe<Scalars['String']>
  tags: Array<Maybe<Tag>>
  title?: Maybe<Scalars['String']>
  updatedAt: Scalars['String']
  url: Scalars['String']
}

export type Comment = {
  __typename?: 'Comment'
  author: User
  createdAt: Scalars['String']
  id: Scalars['ID']
  text?: Maybe<Scalars['String']>
  updatedAt?: Maybe<Scalars['String']>
  viewerCanDelete?: Maybe<Scalars['Boolean']>
  viewerCanEdit?: Maybe<Scalars['Boolean']>
}

export enum CommentType {
  Bookmark = 'BOOKMARK',
  Post = 'POST',
  Question = 'QUESTION',
  Stack = 'STACK',
}

export type EditBookmarkInput = {
  description: Scalars['String']
  faviconUrl: Scalars['String']
  tag: Scalars['String']
  title: Scalars['String']
}

export type EditQuestionInput = {
  description?: Maybe<Scalars['String']>
  title: Scalars['String']
}

export type EditStackInput = {
  description: Scalars['String']
  image: Scalars['String']
  name: Scalars['String']
  tag?: Maybe<Scalars['String']>
  url: Scalars['String']
}

export type EditUserInput = {
  email?: Maybe<Scalars['String']>
  username?: Maybe<Scalars['String']>
}

export type EmailSubscription = {
  __typename?: 'EmailSubscription'
  subscribed?: Maybe<Scalars['Boolean']>
  type?: Maybe<EmailSubscriptionType>
}

export type EmailSubscriptionInput = {
  email?: Maybe<Scalars['String']>
  subscribed: Scalars['Boolean']
  type: EmailSubscriptionType
}

export enum EmailSubscriptionType {
  HackerNews = 'HACKER_NEWS',
  Newsletter = 'NEWSLETTER',
}

export type Episode = {
  __typename?: 'Episode'
  description?: Maybe<Scalars['String']>
  id?: Maybe<Scalars['String']>
  legacy_id?: Maybe<Scalars['String']>
  long_description?: Maybe<Scalars['String']>
  published_at?: Maybe<Scalars['String']>
  status?: Maybe<Scalars['String']>
  title?: Maybe<Scalars['String']>
  token?: Maybe<Scalars['String']>
}

export type Mutation = {
  __typename?: 'Mutation'
  addBookmark?: Maybe<Bookmark>
  addComment?: Maybe<Comment>
  addQuestion?: Maybe<Question>
  addStack?: Maybe<Stack>
  deleteBookmark?: Maybe<Scalars['Boolean']>
  deleteComment?: Maybe<Scalars['Boolean']>
  deleteQuestion?: Maybe<Scalars['Boolean']>
  deleteStack?: Maybe<Scalars['Boolean']>
  deleteUser?: Maybe<Scalars['Boolean']>
  editBookmark?: Maybe<Bookmark>
  editComment?: Maybe<Comment>
  editEmailSubscription?: Maybe<User>
  editQuestion?: Maybe<Question>
  editStack?: Maybe<Stack>
  editUser?: Maybe<User>
  toggleStackUser?: Maybe<Stack>
}

export type MutationAddBookmarkArgs = {
  data: AddBookmarkInput
}

export type MutationAddCommentArgs = {
  refId: Scalars['String']
  text: Scalars['String']
  type: CommentType
}

export type MutationAddQuestionArgs = {
  data: AddQuestionInput
}

export type MutationAddStackArgs = {
  data: AddStackInput
}

export type MutationDeleteBookmarkArgs = {
  id: Scalars['ID']
}

export type MutationDeleteCommentArgs = {
  id: Scalars['ID']
}

export type MutationDeleteQuestionArgs = {
  id: Scalars['ID']
}

export type MutationDeleteStackArgs = {
  id: Scalars['ID']
}

export type MutationEditBookmarkArgs = {
  data: EditBookmarkInput
  id: Scalars['ID']
}

export type MutationEditCommentArgs = {
  id: Scalars['ID']
  text?: Maybe<Scalars['String']>
}

export type MutationEditEmailSubscriptionArgs = {
  data?: Maybe<EmailSubscriptionInput>
}

export type MutationEditQuestionArgs = {
  data: EditQuestionInput
  id: Scalars['ID']
}

export type MutationEditStackArgs = {
  data: EditStackInput
  id: Scalars['ID']
}

export type MutationEditUserArgs = {
  data?: Maybe<EditUserInput>
}

export type MutationToggleStackUserArgs = {
  id: Scalars['ID']
}

export type Post = {
  __typename?: 'Post'
  canonical_url?: Maybe<Scalars['String']>
  comment_id?: Maybe<Scalars['String']>
  created_at?: Maybe<Scalars['String']>
  custom_excerpt?: Maybe<Scalars['String']>
  excerpt?: Maybe<Scalars['String']>
  feature_image?: Maybe<Scalars['String']>
  featured?: Maybe<Scalars['Boolean']>
  html?: Maybe<Scalars['String']>
  id?: Maybe<Scalars['String']>
  meta_description?: Maybe<Scalars['String']>
  meta_title?: Maybe<Scalars['String']>
  og_description?: Maybe<Scalars['String']>
  og_image?: Maybe<Scalars['String']>
  og_title?: Maybe<Scalars['String']>
  publishedAt?: Maybe<Scalars['String']>
  reading_time?: Maybe<Scalars['Int']>
  slug?: Maybe<Scalars['String']>
  title?: Maybe<Scalars['String']>
  twitter_description?: Maybe<Scalars['String']>
  twitter_image?: Maybe<Scalars['String']>
  twitter_title?: Maybe<Scalars['String']>
  updated_at?: Maybe<Scalars['String']>
  url?: Maybe<Scalars['String']>
  uuid?: Maybe<Scalars['String']>
  visibility?: Maybe<Scalars['String']>
}

export type Query = {
  __typename?: 'Query'
  bookmark?: Maybe<Bookmark>
  bookmarks: Array<Maybe<Bookmark>>
  comment?: Maybe<Comment>
  comments: Array<Maybe<Comment>>
  episodes: Array<Maybe<Episode>>
  post?: Maybe<Post>
  posts: Array<Maybe<Post>>
  question?: Maybe<Question>
  questions: Array<Maybe<Question>>
  repos: Array<Maybe<Repo>>
  signedPlaybackUrl?: Maybe<Scalars['String']>
  signedUploadUrl?: Maybe<Scalars['String']>
  stack?: Maybe<Stack>
  stacks: Array<Maybe<Stack>>
  tags: Array<Maybe<Tag>>
  transcription?: Maybe<Scalars['String']>
  user?: Maybe<User>
  viewer?: Maybe<User>
}

export type QueryBookmarkArgs = {
  id: Scalars['ID']
}

export type QueryBookmarksArgs = {
  tag?: Maybe<Scalars['String']>
}

export type QueryCommentArgs = {
  id: Scalars['ID']
}

export type QueryCommentsArgs = {
  refId?: Maybe<Scalars['String']>
  type?: Maybe<CommentType>
}

export type QueryPostArgs = {
  slug: Scalars['String']
}

export type QueryPostsArgs = {
  filter?: Maybe<Scalars['String']>
  first?: Maybe<Scalars['Int']>
  order?: Maybe<Scalars['String']>
}

export type QueryQuestionArgs = {
  id: Scalars['ID']
}

export type QuerySignedPlaybackUrlArgs = {
  id: Scalars['ID']
}

export type QuerySignedUploadUrlArgs = {
  id: Scalars['ID']
}

export type QueryStackArgs = {
  id: Scalars['ID']
}

export type QueryStacksArgs = {
  skip?: Maybe<Scalars['Int']>
}

export type QueryTranscriptionArgs = {
  transcriptionId: Scalars['ID']
}

export type QueryUserArgs = {
  username: Scalars['String']
}

export type Question = {
  __typename?: 'Question'
  author?: Maybe<User>
  commentCount?: Maybe<Scalars['Int']>
  createdAt: Scalars['String']
  description?: Maybe<Scalars['String']>
  id: Scalars['String']
  title: Scalars['String']
  updatedAt?: Maybe<Scalars['String']>
}

export type Repo = {
  __typename?: 'Repo'
  description?: Maybe<Scalars['String']>
  name?: Maybe<Scalars['String']>
  org?: Maybe<Scalars['String']>
  stars?: Maybe<Scalars['Int']>
}

export type Stack = {
  __typename?: 'Stack'
  createdAt: Scalars['String']
  description?: Maybe<Scalars['String']>
  id: Scalars['ID']
  image?: Maybe<Scalars['String']>
  name: Scalars['String']
  tags: Array<Maybe<Tag>>
  updatedAt?: Maybe<Scalars['String']>
  url: Scalars['String']
  usedBy: Array<Maybe<User>>
  usedByViewer?: Maybe<Scalars['Boolean']>
}

export type Tag = {
  __typename?: 'Tag'
  name: Scalars['String']
}

export type User = {
  __typename?: 'User'
  avatar?: Maybe<Scalars['String']>
  createdAt?: Maybe<Scalars['String']>
  email?: Maybe<Scalars['String']>
  emailSubscriptions?: Maybe<Array<Maybe<EmailSubscription>>>
  id: Scalars['ID']
  isViewer?: Maybe<Scalars['Boolean']>
  name?: Maybe<Scalars['String']>
  pendingEmail?: Maybe<Scalars['String']>
  role?: Maybe<UserRole>
  username?: Maybe<Scalars['String']>
}

export enum UserRole {
  Admin = 'ADMIN',
  Blocked = 'BLOCKED',
  User = 'USER',
}

export type BookmarkInfoFragment = {
  __typename: 'Bookmark'
  id: string
  url: string
  host: string
  title?: string | null | undefined
  description?: string | null | undefined
  faviconUrl?: string | null | undefined
}

export type BookmarkInfoWithTagsFragment = {
  __typename: 'Bookmark'
  id: string
  url: string
  host: string
  title?: string | null | undefined
  description?: string | null | undefined
  faviconUrl?: string | null | undefined
  tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
}

export type CommentInfoFragment = {
  __typename: 'Comment'
  id: string
  createdAt: string
  updatedAt?: string | null | undefined
  text?: string | null | undefined
  viewerCanEdit?: boolean | null | undefined
  viewerCanDelete?: boolean | null | undefined
  author: {
    __typename: 'User'
    id: string
    username?: string | null | undefined
    avatar?: string | null | undefined
    name?: string | null | undefined
    role?: UserRole | null | undefined
    isViewer?: boolean | null | undefined
  }
}

export type EpisodeInfoFragment = {
  __typename?: 'Episode'
  id?: string | null | undefined
  description?: string | null | undefined
  legacy_id?: string | null | undefined
  long_description?: string | null | undefined
  published_at?: string | null | undefined
  status?: string | null | undefined
  title?: string | null | undefined
  token?: string | null | undefined
}

export type PostInfoFragment = {
  __typename?: 'Post'
  id?: string | null | undefined
  title?: string | null | undefined
  slug?: string | null | undefined
  updated_at?: string | null | undefined
  publishedAt?: string | null | undefined
  excerpt?: string | null | undefined
  feature_image?: string | null | undefined
  html?: string | null | undefined
}

export type QuestionInfoFragment = {
  __typename?: 'Question'
  id: string
  createdAt: string
  updatedAt?: string | null | undefined
  title: string
  description?: string | null | undefined
  commentCount?: number | null | undefined
  author?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isViewer?: boolean | null | undefined
      }
    | null
    | undefined
}

export type RepoInfoFragment = {
  __typename?: 'Repo'
  org?: string | null | undefined
  name?: string | null | undefined
  description?: string | null | undefined
  stars?: number | null | undefined
}

export type StackInfoFragment = {
  __typename: 'Stack'
  id: string
  createdAt: string
  updatedAt?: string | null | undefined
  name: string
  description?: string | null | undefined
  url: string
  image?: string | null | undefined
}

export type StackInfoWithTagsFragment = {
  __typename: 'Stack'
  id: string
  createdAt: string
  updatedAt?: string | null | undefined
  name: string
  description?: string | null | undefined
  url: string
  image?: string | null | undefined
  tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
}

export type UserInfoFragment = {
  __typename: 'User'
  id: string
  username?: string | null | undefined
  avatar?: string | null | undefined
  name?: string | null | undefined
  role?: UserRole | null | undefined
  isViewer?: boolean | null | undefined
}

export type UserSettingsFragment = {
  __typename?: 'User'
  email?: string | null | undefined
  pendingEmail?: string | null | undefined
  emailSubscriptions?:
    | Array<
        | {
            __typename?: 'EmailSubscription'
            type?: EmailSubscriptionType | null | undefined
            subscribed?: boolean | null | undefined
          }
        | null
        | undefined
      >
    | null
    | undefined
}

export type EditBookmarkMutationVariables = Exact<{
  id: Scalars['ID']
  data: EditBookmarkInput
}>

export type EditBookmarkMutation = {
  __typename?: 'Mutation'
  editBookmark?:
    | {
        __typename: 'Bookmark'
        id: string
        url: string
        host: string
        title?: string | null | undefined
        description?: string | null | undefined
        faviconUrl?: string | null | undefined
        tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
      }
    | null
    | undefined
}

export type DeleteBookmarkMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type DeleteBookmarkMutation = {
  __typename?: 'Mutation'
  deleteBookmark?: boolean | null | undefined
}

export type AddBookmarkMutationVariables = Exact<{
  data: AddBookmarkInput
}>

export type AddBookmarkMutation = {
  __typename?: 'Mutation'
  addBookmark?:
    | {
        __typename: 'Bookmark'
        id: string
        url: string
        host: string
        title?: string | null | undefined
        description?: string | null | undefined
        faviconUrl?: string | null | undefined
        tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
      }
    | null
    | undefined
}

export type AddCommentMutationVariables = Exact<{
  refId: Scalars['String']
  type: CommentType
  text: Scalars['String']
}>

export type AddCommentMutation = {
  __typename?: 'Mutation'
  addComment?:
    | {
        __typename: 'Comment'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        text?: string | null | undefined
        viewerCanEdit?: boolean | null | undefined
        viewerCanDelete?: boolean | null | undefined
        author: {
          __typename: 'User'
          id: string
          username?: string | null | undefined
          avatar?: string | null | undefined
          name?: string | null | undefined
          role?: UserRole | null | undefined
          isViewer?: boolean | null | undefined
        }
      }
    | null
    | undefined
}

export type EditCommentMutationVariables = Exact<{
  id: Scalars['ID']
  text: Scalars['String']
}>

export type EditCommentMutation = {
  __typename?: 'Mutation'
  editComment?:
    | {
        __typename: 'Comment'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        text?: string | null | undefined
        viewerCanEdit?: boolean | null | undefined
        viewerCanDelete?: boolean | null | undefined
        author: {
          __typename: 'User'
          id: string
          username?: string | null | undefined
          avatar?: string | null | undefined
          name?: string | null | undefined
          role?: UserRole | null | undefined
          isViewer?: boolean | null | undefined
        }
      }
    | null
    | undefined
}

export type DeleteCommentMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type DeleteCommentMutation = {
  __typename?: 'Mutation'
  deleteComment?: boolean | null | undefined
}

export type EditEmailSubscriptionMutationVariables = Exact<{
  data?: Maybe<EmailSubscriptionInput>
}>

export type EditEmailSubscriptionMutation = {
  __typename?: 'Mutation'
  editEmailSubscription?:
    | {
        __typename?: 'User'
        emailSubscriptions?:
          | Array<
              | {
                  __typename?: 'EmailSubscription'
                  subscribed?: boolean | null | undefined
                  type?: EmailSubscriptionType | null | undefined
                }
              | null
              | undefined
            >
          | null
          | undefined
      }
    | null
    | undefined
}

export type EditQuestionMutationVariables = Exact<{
  id: Scalars['ID']
  data: EditQuestionInput
}>

export type EditQuestionMutation = {
  __typename?: 'Mutation'
  editQuestion?:
    | {
        __typename?: 'Question'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        title: string
        description?: string | null | undefined
        commentCount?: number | null | undefined
        author?:
          | {
              __typename: 'User'
              id: string
              username?: string | null | undefined
              avatar?: string | null | undefined
              name?: string | null | undefined
              role?: UserRole | null | undefined
              isViewer?: boolean | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type DeleteQuestionMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type DeleteQuestionMutation = {
  __typename?: 'Mutation'
  deleteQuestion?: boolean | null | undefined
}

export type AddQuestionMutationVariables = Exact<{
  data: AddQuestionInput
}>

export type AddQuestionMutation = {
  __typename?: 'Mutation'
  addQuestion?:
    | {
        __typename?: 'Question'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        title: string
        description?: string | null | undefined
        commentCount?: number | null | undefined
        author?:
          | {
              __typename: 'User'
              id: string
              username?: string | null | undefined
              avatar?: string | null | undefined
              name?: string | null | undefined
              role?: UserRole | null | undefined
              isViewer?: boolean | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type EditStackMutationVariables = Exact<{
  id: Scalars['ID']
  data: EditStackInput
}>

export type EditStackMutation = {
  __typename?: 'Mutation'
  editStack?:
    | {
        __typename: 'Stack'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        name: string
        description?: string | null | undefined
        url: string
        image?: string | null | undefined
        tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
      }
    | null
    | undefined
}

export type DeleteStackMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type DeleteStackMutation = {
  __typename?: 'Mutation'
  deleteStack?: boolean | null | undefined
}

export type AddStackMutationVariables = Exact<{
  data: AddStackInput
}>

export type AddStackMutation = {
  __typename?: 'Mutation'
  addStack?:
    | {
        __typename: 'Stack'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        name: string
        description?: string | null | undefined
        url: string
        image?: string | null | undefined
        tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
      }
    | null
    | undefined
}

export type ToggleStackUserMutationVariables = Exact<{
  id: Scalars['ID']
}>

export type ToggleStackUserMutation = {
  __typename?: 'Mutation'
  toggleStackUser?:
    | {
        __typename?: 'Stack'
        id: string
        usedBy: Array<
          | {
              __typename: 'User'
              id: string
              username?: string | null | undefined
              avatar?: string | null | undefined
              name?: string | null | undefined
              role?: UserRole | null | undefined
              isViewer?: boolean | null | undefined
            }
          | null
          | undefined
        >
      }
    | null
    | undefined
}

export type DeleteUserMutationVariables = Exact<{ [key: string]: never }>

export type DeleteUserMutation = {
  __typename?: 'Mutation'
  deleteUser?: boolean | null | undefined
}

export type EditUserMutationVariables = Exact<{
  data?: Maybe<EditUserInput>
}>

export type EditUserMutation = {
  __typename?: 'Mutation'
  editUser?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isViewer?: boolean | null | undefined
      }
    | null
    | undefined
}

export type GetBookmarksQueryVariables = Exact<{
  tag?: Maybe<Scalars['String']>
}>

export type GetBookmarksQuery = {
  __typename?: 'Query'
  bookmarks: Array<
    | {
        __typename: 'Bookmark'
        id: string
        url: string
        host: string
        title?: string | null | undefined
        description?: string | null | undefined
        faviconUrl?: string | null | undefined
        tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
      }
    | null
    | undefined
  >
}

export type GetBookmarkQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type GetBookmarkQuery = {
  __typename?: 'Query'
  bookmark?:
    | {
        __typename: 'Bookmark'
        id: string
        url: string
        host: string
        title?: string | null | undefined
        description?: string | null | undefined
        faviconUrl?: string | null | undefined
        tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
      }
    | null
    | undefined
}

export type GetCommentsQueryVariables = Exact<{
  refId?: Maybe<Scalars['String']>
  type?: Maybe<CommentType>
}>

export type GetCommentsQuery = {
  __typename?: 'Query'
  comments: Array<
    | {
        __typename: 'Comment'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        text?: string | null | undefined
        viewerCanEdit?: boolean | null | undefined
        viewerCanDelete?: boolean | null | undefined
        author: {
          __typename: 'User'
          id: string
          username?: string | null | undefined
          avatar?: string | null | undefined
          name?: string | null | undefined
          role?: UserRole | null | undefined
          isViewer?: boolean | null | undefined
        }
      }
    | null
    | undefined
  >
}

export type GetEpisodesQueryVariables = Exact<{ [key: string]: never }>

export type GetEpisodesQuery = {
  __typename?: 'Query'
  episodes: Array<
    | {
        __typename?: 'Episode'
        id?: string | null | undefined
        description?: string | null | undefined
        legacy_id?: string | null | undefined
        long_description?: string | null | undefined
        published_at?: string | null | undefined
        status?: string | null | undefined
        title?: string | null | undefined
        token?: string | null | undefined
      }
    | null
    | undefined
  >
}

export type GetPostsQueryVariables = Exact<{ [key: string]: never }>

export type GetPostsQuery = {
  __typename?: 'Query'
  posts: Array<
    | {
        __typename?: 'Post'
        id?: string | null | undefined
        title?: string | null | undefined
        slug?: string | null | undefined
        updated_at?: string | null | undefined
        publishedAt?: string | null | undefined
        excerpt?: string | null | undefined
        feature_image?: string | null | undefined
        html?: string | null | undefined
      }
    | null
    | undefined
  >
}

export type GetPostQueryVariables = Exact<{
  slug: Scalars['String']
}>

export type GetPostQuery = {
  __typename?: 'Query'
  post?:
    | {
        __typename?: 'Post'
        id?: string | null | undefined
        title?: string | null | undefined
        slug?: string | null | undefined
        updated_at?: string | null | undefined
        publishedAt?: string | null | undefined
        excerpt?: string | null | undefined
        feature_image?: string | null | undefined
        html?: string | null | undefined
      }
    | null
    | undefined
}

export type GetQuestionsQueryVariables = Exact<{ [key: string]: never }>

export type GetQuestionsQuery = {
  __typename?: 'Query'
  questions: Array<
    | {
        __typename?: 'Question'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        title: string
        description?: string | null | undefined
        commentCount?: number | null | undefined
        author?:
          | {
              __typename: 'User'
              id: string
              username?: string | null | undefined
              avatar?: string | null | undefined
              name?: string | null | undefined
              role?: UserRole | null | undefined
              isViewer?: boolean | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
  >
}

export type GetQuestionQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type GetQuestionQuery = {
  __typename?: 'Query'
  question?:
    | {
        __typename?: 'Question'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        title: string
        description?: string | null | undefined
        commentCount?: number | null | undefined
        author?:
          | {
              __typename: 'User'
              id: string
              username?: string | null | undefined
              avatar?: string | null | undefined
              name?: string | null | undefined
              role?: UserRole | null | undefined
              isViewer?: boolean | null | undefined
            }
          | null
          | undefined
      }
    | null
    | undefined
}

export type GetStacksQueryVariables = Exact<{ [key: string]: never }>

export type GetStacksQuery = {
  __typename?: 'Query'
  stacks: Array<
    | {
        __typename: 'Stack'
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        name: string
        description?: string | null | undefined
        url: string
        image?: string | null | undefined
      }
    | null
    | undefined
  >
}

export type GetStackQueryVariables = Exact<{
  id: Scalars['ID']
}>

export type GetStackQuery = {
  __typename?: 'Query'
  stack?:
    | {
        __typename: 'Stack'
        usedByViewer?: boolean | null | undefined
        id: string
        createdAt: string
        updatedAt?: string | null | undefined
        name: string
        description?: string | null | undefined
        url: string
        image?: string | null | undefined
        usedBy: Array<
          | {
              __typename: 'User'
              id: string
              username?: string | null | undefined
              avatar?: string | null | undefined
              name?: string | null | undefined
              role?: UserRole | null | undefined
              isViewer?: boolean | null | undefined
            }
          | null
          | undefined
        >
        tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
      }
    | null
    | undefined
}

export type GetTagsQueryVariables = Exact<{ [key: string]: never }>

export type GetTagsQuery = {
  __typename?: 'Query'
  tags: Array<{ __typename?: 'Tag'; name: string } | null | undefined>
}

export type GetUserQueryVariables = Exact<{
  username: Scalars['String']
}>

export type GetUserQuery = {
  __typename?: 'Query'
  user?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isViewer?: boolean | null | undefined
      }
    | null
    | undefined
}

export type ViewerQueryVariables = Exact<{ [key: string]: never }>

export type ViewerQuery = {
  __typename?: 'Query'
  viewer?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isViewer?: boolean | null | undefined
      }
    | null
    | undefined
}

export type GetViewerWithSettingsQueryVariables = Exact<{
  [key: string]: never
}>

export type GetViewerWithSettingsQuery = {
  __typename?: 'Query'
  viewer?:
    | {
        __typename: 'User'
        id: string
        username?: string | null | undefined
        avatar?: string | null | undefined
        name?: string | null | undefined
        role?: UserRole | null | undefined
        isViewer?: boolean | null | undefined
        email?: string | null | undefined
        pendingEmail?: string | null | undefined
        emailSubscriptions?:
          | Array<
              | {
                  __typename?: 'EmailSubscription'
                  type?: EmailSubscriptionType | null | undefined
                  subscribed?: boolean | null | undefined
                }
              | null
              | undefined
            >
          | null
          | undefined
      }
    | null
    | undefined
}

export const BookmarkInfoFragmentDoc = gql`
  fragment BookmarkInfo on Bookmark {
    __typename
    id
    url
    host
    title
    description
    faviconUrl
  }
`
export const BookmarkInfoWithTagsFragmentDoc = gql`
  fragment BookmarkInfoWithTags on Bookmark {
    ...BookmarkInfo
    tags {
      name
    }
  }
  ${BookmarkInfoFragmentDoc}
`
export const UserInfoFragmentDoc = gql`
  fragment UserInfo on User {
    __typename
    id
    username
    avatar
    name
    role
    isViewer
  }
`
export const CommentInfoFragmentDoc = gql`
  fragment CommentInfo on Comment {
    __typename
    id
    createdAt
    updatedAt
    text
    viewerCanEdit
    viewerCanDelete
    author {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`
export const EpisodeInfoFragmentDoc = gql`
  fragment EpisodeInfo on Episode {
    id
    description
    legacy_id
    long_description
    published_at
    status
    title
    token
  }
`
export const PostInfoFragmentDoc = gql`
  fragment PostInfo on Post {
    id
    title
    slug
    updated_at
    publishedAt
    excerpt
    feature_image
    html
  }
`
export const QuestionInfoFragmentDoc = gql`
  fragment QuestionInfo on Question {
    id
    createdAt
    updatedAt
    title
    description
    commentCount
    author {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`
export const RepoInfoFragmentDoc = gql`
  fragment RepoInfo on Repo {
    org
    name
    description
    stars
  }
`
export const StackInfoFragmentDoc = gql`
  fragment StackInfo on Stack {
    __typename
    id
    createdAt
    updatedAt
    name
    description
    url
    image
  }
`
export const StackInfoWithTagsFragmentDoc = gql`
  fragment StackInfoWithTags on Stack {
    ...StackInfo
    tags {
      name
    }
  }
  ${StackInfoFragmentDoc}
`
export const UserSettingsFragmentDoc = gql`
  fragment UserSettings on User {
    email
    pendingEmail
    emailSubscriptions {
      type
      subscribed
    }
  }
`
export const EditBookmarkDocument = gql`
  mutation editBookmark($id: ID!, $data: EditBookmarkInput!) {
    editBookmark(id: $id, data: $data) {
      ...BookmarkInfoWithTags
    }
  }
  ${BookmarkInfoWithTagsFragmentDoc}
`
export type EditBookmarkMutationFn = Apollo.MutationFunction<
  EditBookmarkMutation,
  EditBookmarkMutationVariables
>

/**
 * __useEditBookmarkMutation__
 *
 * To run a mutation, you first call `useEditBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editBookmarkMutation, { data, loading, error }] = useEditBookmarkMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditBookmarkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditBookmarkMutation,
    EditBookmarkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditBookmarkMutation,
    EditBookmarkMutationVariables
  >(EditBookmarkDocument, options)
}
export type EditBookmarkMutationHookResult = ReturnType<
  typeof useEditBookmarkMutation
>
export type EditBookmarkMutationResult =
  Apollo.MutationResult<EditBookmarkMutation>
export type EditBookmarkMutationOptions = Apollo.BaseMutationOptions<
  EditBookmarkMutation,
  EditBookmarkMutationVariables
>
export const DeleteBookmarkDocument = gql`
  mutation deleteBookmark($id: ID!) {
    deleteBookmark(id: $id)
  }
`
export type DeleteBookmarkMutationFn = Apollo.MutationFunction<
  DeleteBookmarkMutation,
  DeleteBookmarkMutationVariables
>

/**
 * __useDeleteBookmarkMutation__
 *
 * To run a mutation, you first call `useDeleteBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBookmarkMutation, { data, loading, error }] = useDeleteBookmarkMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteBookmarkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteBookmarkMutation,
    DeleteBookmarkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeleteBookmarkMutation,
    DeleteBookmarkMutationVariables
  >(DeleteBookmarkDocument, options)
}
export type DeleteBookmarkMutationHookResult = ReturnType<
  typeof useDeleteBookmarkMutation
>
export type DeleteBookmarkMutationResult =
  Apollo.MutationResult<DeleteBookmarkMutation>
export type DeleteBookmarkMutationOptions = Apollo.BaseMutationOptions<
  DeleteBookmarkMutation,
  DeleteBookmarkMutationVariables
>
export const AddBookmarkDocument = gql`
  mutation addBookmark($data: AddBookmarkInput!) {
    addBookmark(data: $data) {
      ...BookmarkInfoWithTags
    }
  }
  ${BookmarkInfoWithTagsFragmentDoc}
`
export type AddBookmarkMutationFn = Apollo.MutationFunction<
  AddBookmarkMutation,
  AddBookmarkMutationVariables
>

/**
 * __useAddBookmarkMutation__
 *
 * To run a mutation, you first call `useAddBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addBookmarkMutation, { data, loading, error }] = useAddBookmarkMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAddBookmarkMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddBookmarkMutation,
    AddBookmarkMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddBookmarkMutation, AddBookmarkMutationVariables>(
    AddBookmarkDocument,
    options
  )
}
export type AddBookmarkMutationHookResult = ReturnType<
  typeof useAddBookmarkMutation
>
export type AddBookmarkMutationResult =
  Apollo.MutationResult<AddBookmarkMutation>
export type AddBookmarkMutationOptions = Apollo.BaseMutationOptions<
  AddBookmarkMutation,
  AddBookmarkMutationVariables
>
export const AddCommentDocument = gql`
  mutation addComment($refId: String!, $type: CommentType!, $text: String!) {
    addComment(refId: $refId, type: $type, text: $text) {
      ...CommentInfo
    }
  }
  ${CommentInfoFragmentDoc}
`
export type AddCommentMutationFn = Apollo.MutationFunction<
  AddCommentMutation,
  AddCommentMutationVariables
>

/**
 * __useAddCommentMutation__
 *
 * To run a mutation, you first call `useAddCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCommentMutation, { data, loading, error }] = useAddCommentMutation({
 *   variables: {
 *      refId: // value for 'refId'
 *      type: // value for 'type'
 *      text: // value for 'text'
 *   },
 * });
 */
export function useAddCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddCommentMutation,
    AddCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddCommentMutation, AddCommentMutationVariables>(
    AddCommentDocument,
    options
  )
}
export type AddCommentMutationHookResult = ReturnType<
  typeof useAddCommentMutation
>
export type AddCommentMutationResult = Apollo.MutationResult<AddCommentMutation>
export type AddCommentMutationOptions = Apollo.BaseMutationOptions<
  AddCommentMutation,
  AddCommentMutationVariables
>
export const EditCommentDocument = gql`
  mutation editComment($id: ID!, $text: String!) {
    editComment(id: $id, text: $text) {
      ...CommentInfo
    }
  }
  ${CommentInfoFragmentDoc}
`
export type EditCommentMutationFn = Apollo.MutationFunction<
  EditCommentMutation,
  EditCommentMutationVariables
>

/**
 * __useEditCommentMutation__
 *
 * To run a mutation, you first call `useEditCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editCommentMutation, { data, loading, error }] = useEditCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *      text: // value for 'text'
 *   },
 * });
 */
export function useEditCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditCommentMutation,
    EditCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditCommentMutation, EditCommentMutationVariables>(
    EditCommentDocument,
    options
  )
}
export type EditCommentMutationHookResult = ReturnType<
  typeof useEditCommentMutation
>
export type EditCommentMutationResult =
  Apollo.MutationResult<EditCommentMutation>
export type EditCommentMutationOptions = Apollo.BaseMutationOptions<
  EditCommentMutation,
  EditCommentMutationVariables
>
export const DeleteCommentDocument = gql`
  mutation deleteComment($id: ID!) {
    deleteComment(id: $id)
  }
`
export type DeleteCommentMutationFn = Apollo.MutationFunction<
  DeleteCommentMutation,
  DeleteCommentMutationVariables
>

/**
 * __useDeleteCommentMutation__
 *
 * To run a mutation, you first call `useDeleteCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCommentMutation, { data, loading, error }] = useDeleteCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteCommentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteCommentMutation,
    DeleteCommentMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeleteCommentMutation,
    DeleteCommentMutationVariables
  >(DeleteCommentDocument, options)
}
export type DeleteCommentMutationHookResult = ReturnType<
  typeof useDeleteCommentMutation
>
export type DeleteCommentMutationResult =
  Apollo.MutationResult<DeleteCommentMutation>
export type DeleteCommentMutationOptions = Apollo.BaseMutationOptions<
  DeleteCommentMutation,
  DeleteCommentMutationVariables
>
export const EditEmailSubscriptionDocument = gql`
  mutation editEmailSubscription($data: EmailSubscriptionInput) {
    editEmailSubscription(data: $data) {
      emailSubscriptions {
        subscribed
        type
      }
    }
  }
`
export type EditEmailSubscriptionMutationFn = Apollo.MutationFunction<
  EditEmailSubscriptionMutation,
  EditEmailSubscriptionMutationVariables
>

/**
 * __useEditEmailSubscriptionMutation__
 *
 * To run a mutation, you first call `useEditEmailSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditEmailSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editEmailSubscriptionMutation, { data, loading, error }] = useEditEmailSubscriptionMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditEmailSubscriptionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditEmailSubscriptionMutation,
    EditEmailSubscriptionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditEmailSubscriptionMutation,
    EditEmailSubscriptionMutationVariables
  >(EditEmailSubscriptionDocument, options)
}
export type EditEmailSubscriptionMutationHookResult = ReturnType<
  typeof useEditEmailSubscriptionMutation
>
export type EditEmailSubscriptionMutationResult =
  Apollo.MutationResult<EditEmailSubscriptionMutation>
export type EditEmailSubscriptionMutationOptions = Apollo.BaseMutationOptions<
  EditEmailSubscriptionMutation,
  EditEmailSubscriptionMutationVariables
>
export const EditQuestionDocument = gql`
  mutation editQuestion($id: ID!, $data: EditQuestionInput!) {
    editQuestion(id: $id, data: $data) {
      ...QuestionInfo
    }
  }
  ${QuestionInfoFragmentDoc}
`
export type EditQuestionMutationFn = Apollo.MutationFunction<
  EditQuestionMutation,
  EditQuestionMutationVariables
>

/**
 * __useEditQuestionMutation__
 *
 * To run a mutation, you first call `useEditQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editQuestionMutation, { data, loading, error }] = useEditQuestionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditQuestionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditQuestionMutation,
    EditQuestionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    EditQuestionMutation,
    EditQuestionMutationVariables
  >(EditQuestionDocument, options)
}
export type EditQuestionMutationHookResult = ReturnType<
  typeof useEditQuestionMutation
>
export type EditQuestionMutationResult =
  Apollo.MutationResult<EditQuestionMutation>
export type EditQuestionMutationOptions = Apollo.BaseMutationOptions<
  EditQuestionMutation,
  EditQuestionMutationVariables
>
export const DeleteQuestionDocument = gql`
  mutation deleteQuestion($id: ID!) {
    deleteQuestion(id: $id)
  }
`
export type DeleteQuestionMutationFn = Apollo.MutationFunction<
  DeleteQuestionMutation,
  DeleteQuestionMutationVariables
>

/**
 * __useDeleteQuestionMutation__
 *
 * To run a mutation, you first call `useDeleteQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteQuestionMutation, { data, loading, error }] = useDeleteQuestionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteQuestionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteQuestionMutation,
    DeleteQuestionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeleteQuestionMutation,
    DeleteQuestionMutationVariables
  >(DeleteQuestionDocument, options)
}
export type DeleteQuestionMutationHookResult = ReturnType<
  typeof useDeleteQuestionMutation
>
export type DeleteQuestionMutationResult =
  Apollo.MutationResult<DeleteQuestionMutation>
export type DeleteQuestionMutationOptions = Apollo.BaseMutationOptions<
  DeleteQuestionMutation,
  DeleteQuestionMutationVariables
>
export const AddQuestionDocument = gql`
  mutation addQuestion($data: AddQuestionInput!) {
    addQuestion(data: $data) {
      ...QuestionInfo
    }
  }
  ${QuestionInfoFragmentDoc}
`
export type AddQuestionMutationFn = Apollo.MutationFunction<
  AddQuestionMutation,
  AddQuestionMutationVariables
>

/**
 * __useAddQuestionMutation__
 *
 * To run a mutation, you first call `useAddQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addQuestionMutation, { data, loading, error }] = useAddQuestionMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAddQuestionMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddQuestionMutation,
    AddQuestionMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddQuestionMutation, AddQuestionMutationVariables>(
    AddQuestionDocument,
    options
  )
}
export type AddQuestionMutationHookResult = ReturnType<
  typeof useAddQuestionMutation
>
export type AddQuestionMutationResult =
  Apollo.MutationResult<AddQuestionMutation>
export type AddQuestionMutationOptions = Apollo.BaseMutationOptions<
  AddQuestionMutation,
  AddQuestionMutationVariables
>
export const EditStackDocument = gql`
  mutation editStack($id: ID!, $data: EditStackInput!) {
    editStack(id: $id, data: $data) {
      ...StackInfoWithTags
    }
  }
  ${StackInfoWithTagsFragmentDoc}
`
export type EditStackMutationFn = Apollo.MutationFunction<
  EditStackMutation,
  EditStackMutationVariables
>

/**
 * __useEditStackMutation__
 *
 * To run a mutation, you first call `useEditStackMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditStackMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editStackMutation, { data, loading, error }] = useEditStackMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditStackMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditStackMutation,
    EditStackMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditStackMutation, EditStackMutationVariables>(
    EditStackDocument,
    options
  )
}
export type EditStackMutationHookResult = ReturnType<
  typeof useEditStackMutation
>
export type EditStackMutationResult = Apollo.MutationResult<EditStackMutation>
export type EditStackMutationOptions = Apollo.BaseMutationOptions<
  EditStackMutation,
  EditStackMutationVariables
>
export const DeleteStackDocument = gql`
  mutation deleteStack($id: ID!) {
    deleteStack(id: $id)
  }
`
export type DeleteStackMutationFn = Apollo.MutationFunction<
  DeleteStackMutation,
  DeleteStackMutationVariables
>

/**
 * __useDeleteStackMutation__
 *
 * To run a mutation, you first call `useDeleteStackMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteStackMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteStackMutation, { data, loading, error }] = useDeleteStackMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteStackMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteStackMutation,
    DeleteStackMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteStackMutation, DeleteStackMutationVariables>(
    DeleteStackDocument,
    options
  )
}
export type DeleteStackMutationHookResult = ReturnType<
  typeof useDeleteStackMutation
>
export type DeleteStackMutationResult =
  Apollo.MutationResult<DeleteStackMutation>
export type DeleteStackMutationOptions = Apollo.BaseMutationOptions<
  DeleteStackMutation,
  DeleteStackMutationVariables
>
export const AddStackDocument = gql`
  mutation addStack($data: AddStackInput!) {
    addStack(data: $data) {
      ...StackInfoWithTags
    }
  }
  ${StackInfoWithTagsFragmentDoc}
`
export type AddStackMutationFn = Apollo.MutationFunction<
  AddStackMutation,
  AddStackMutationVariables
>

/**
 * __useAddStackMutation__
 *
 * To run a mutation, you first call `useAddStackMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddStackMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addStackMutation, { data, loading, error }] = useAddStackMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAddStackMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AddStackMutation,
    AddStackMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AddStackMutation, AddStackMutationVariables>(
    AddStackDocument,
    options
  )
}
export type AddStackMutationHookResult = ReturnType<typeof useAddStackMutation>
export type AddStackMutationResult = Apollo.MutationResult<AddStackMutation>
export type AddStackMutationOptions = Apollo.BaseMutationOptions<
  AddStackMutation,
  AddStackMutationVariables
>
export const ToggleStackUserDocument = gql`
  mutation toggleStackUser($id: ID!) {
    toggleStackUser(id: $id) {
      id
      usedBy {
        ...UserInfo
      }
    }
  }
  ${UserInfoFragmentDoc}
`
export type ToggleStackUserMutationFn = Apollo.MutationFunction<
  ToggleStackUserMutation,
  ToggleStackUserMutationVariables
>

/**
 * __useToggleStackUserMutation__
 *
 * To run a mutation, you first call `useToggleStackUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useToggleStackUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [toggleStackUserMutation, { data, loading, error }] = useToggleStackUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useToggleStackUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    ToggleStackUserMutation,
    ToggleStackUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    ToggleStackUserMutation,
    ToggleStackUserMutationVariables
  >(ToggleStackUserDocument, options)
}
export type ToggleStackUserMutationHookResult = ReturnType<
  typeof useToggleStackUserMutation
>
export type ToggleStackUserMutationResult =
  Apollo.MutationResult<ToggleStackUserMutation>
export type ToggleStackUserMutationOptions = Apollo.BaseMutationOptions<
  ToggleStackUserMutation,
  ToggleStackUserMutationVariables
>
export const DeleteUserDocument = gql`
  mutation deleteUser {
    deleteUser
  }
`
export type DeleteUserMutationFn = Apollo.MutationFunction<
  DeleteUserMutation,
  DeleteUserMutationVariables
>

/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *   },
 * });
 */
export function useDeleteUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeleteUserMutation,
    DeleteUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<DeleteUserMutation, DeleteUserMutationVariables>(
    DeleteUserDocument,
    options
  )
}
export type DeleteUserMutationHookResult = ReturnType<
  typeof useDeleteUserMutation
>
export type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>
export type DeleteUserMutationOptions = Apollo.BaseMutationOptions<
  DeleteUserMutation,
  DeleteUserMutationVariables
>
export const EditUserDocument = gql`
  mutation editUser($data: EditUserInput) {
    editUser(data: $data) {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`
export type EditUserMutationFn = Apollo.MutationFunction<
  EditUserMutation,
  EditUserMutationVariables
>

/**
 * __useEditUserMutation__
 *
 * To run a mutation, you first call `useEditUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editUserMutation, { data, loading, error }] = useEditUserMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useEditUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    EditUserMutation,
    EditUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<EditUserMutation, EditUserMutationVariables>(
    EditUserDocument,
    options
  )
}
export type EditUserMutationHookResult = ReturnType<typeof useEditUserMutation>
export type EditUserMutationResult = Apollo.MutationResult<EditUserMutation>
export type EditUserMutationOptions = Apollo.BaseMutationOptions<
  EditUserMutation,
  EditUserMutationVariables
>
export const GetBookmarksDocument = gql`
  query GetBookmarks($tag: String) {
    bookmarks(tag: $tag) {
      ...BookmarkInfoWithTags
    }
  }
  ${BookmarkInfoWithTagsFragmentDoc}
`

/**
 * __useGetBookmarksQuery__
 *
 * To run a query within a React component, call `useGetBookmarksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBookmarksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBookmarksQuery({
 *   variables: {
 *      tag: // value for 'tag'
 *   },
 * });
 */
export function useGetBookmarksQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetBookmarksQuery,
    GetBookmarksQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBookmarksQuery, GetBookmarksQueryVariables>(
    GetBookmarksDocument,
    options
  )
}
export function useGetBookmarksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetBookmarksQuery,
    GetBookmarksQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBookmarksQuery, GetBookmarksQueryVariables>(
    GetBookmarksDocument,
    options
  )
}
export type GetBookmarksQueryHookResult = ReturnType<
  typeof useGetBookmarksQuery
>
export type GetBookmarksLazyQueryHookResult = ReturnType<
  typeof useGetBookmarksLazyQuery
>
export type GetBookmarksQueryResult = Apollo.QueryResult<
  GetBookmarksQuery,
  GetBookmarksQueryVariables
>
export const GetBookmarkDocument = gql`
  query GetBookmark($id: ID!) {
    bookmark(id: $id) {
      ...BookmarkInfoWithTags
    }
  }
  ${BookmarkInfoWithTagsFragmentDoc}
`

/**
 * __useGetBookmarkQuery__
 *
 * To run a query within a React component, call `useGetBookmarkQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBookmarkQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBookmarkQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetBookmarkQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetBookmarkQuery,
    GetBookmarkQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetBookmarkQuery, GetBookmarkQueryVariables>(
    GetBookmarkDocument,
    options
  )
}
export function useGetBookmarkLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetBookmarkQuery,
    GetBookmarkQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetBookmarkQuery, GetBookmarkQueryVariables>(
    GetBookmarkDocument,
    options
  )
}
export type GetBookmarkQueryHookResult = ReturnType<typeof useGetBookmarkQuery>
export type GetBookmarkLazyQueryHookResult = ReturnType<
  typeof useGetBookmarkLazyQuery
>
export type GetBookmarkQueryResult = Apollo.QueryResult<
  GetBookmarkQuery,
  GetBookmarkQueryVariables
>
export const GetCommentsDocument = gql`
  query getComments($refId: String, $type: CommentType) {
    comments(refId: $refId, type: $type) {
      ...CommentInfo
    }
  }
  ${CommentInfoFragmentDoc}
`

/**
 * __useGetCommentsQuery__
 *
 * To run a query within a React component, call `useGetCommentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCommentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCommentsQuery({
 *   variables: {
 *      refId: // value for 'refId'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useGetCommentsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetCommentsQuery,
    GetCommentsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetCommentsQuery, GetCommentsQueryVariables>(
    GetCommentsDocument,
    options
  )
}
export function useGetCommentsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetCommentsQuery,
    GetCommentsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetCommentsQuery, GetCommentsQueryVariables>(
    GetCommentsDocument,
    options
  )
}
export type GetCommentsQueryHookResult = ReturnType<typeof useGetCommentsQuery>
export type GetCommentsLazyQueryHookResult = ReturnType<
  typeof useGetCommentsLazyQuery
>
export type GetCommentsQueryResult = Apollo.QueryResult<
  GetCommentsQuery,
  GetCommentsQueryVariables
>
export const GetEpisodesDocument = gql`
  query GetEpisodes {
    episodes {
      ...EpisodeInfo
    }
  }
  ${EpisodeInfoFragmentDoc}
`

/**
 * __useGetEpisodesQuery__
 *
 * To run a query within a React component, call `useGetEpisodesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEpisodesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEpisodesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetEpisodesQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetEpisodesQuery,
    GetEpisodesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetEpisodesQuery, GetEpisodesQueryVariables>(
    GetEpisodesDocument,
    options
  )
}
export function useGetEpisodesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetEpisodesQuery,
    GetEpisodesQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetEpisodesQuery, GetEpisodesQueryVariables>(
    GetEpisodesDocument,
    options
  )
}
export type GetEpisodesQueryHookResult = ReturnType<typeof useGetEpisodesQuery>
export type GetEpisodesLazyQueryHookResult = ReturnType<
  typeof useGetEpisodesLazyQuery
>
export type GetEpisodesQueryResult = Apollo.QueryResult<
  GetEpisodesQuery,
  GetEpisodesQueryVariables
>
export const GetPostsDocument = gql`
  query GetPosts {
    posts {
      ...PostInfo
    }
  }
  ${PostInfoFragmentDoc}
`

/**
 * __useGetPostsQuery__
 *
 * To run a query within a React component, call `useGetPostsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPostsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPostsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetPostsQuery, GetPostsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPostsQuery, GetPostsQueryVariables>(
    GetPostsDocument,
    options
  )
}
export function useGetPostsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetPostsQuery,
    GetPostsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPostsQuery, GetPostsQueryVariables>(
    GetPostsDocument,
    options
  )
}
export type GetPostsQueryHookResult = ReturnType<typeof useGetPostsQuery>
export type GetPostsLazyQueryHookResult = ReturnType<
  typeof useGetPostsLazyQuery
>
export type GetPostsQueryResult = Apollo.QueryResult<
  GetPostsQuery,
  GetPostsQueryVariables
>
export const GetPostDocument = gql`
  query GetPost($slug: String!) {
    post(slug: $slug) {
      ...PostInfo
    }
  }
  ${PostInfoFragmentDoc}
`

/**
 * __useGetPostQuery__
 *
 * To run a query within a React component, call `useGetPostQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPostQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useGetPostQuery(
  baseOptions: Apollo.QueryHookOptions<GetPostQuery, GetPostQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetPostQuery, GetPostQueryVariables>(
    GetPostDocument,
    options
  )
}
export function useGetPostLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetPostQuery, GetPostQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetPostQuery, GetPostQueryVariables>(
    GetPostDocument,
    options
  )
}
export type GetPostQueryHookResult = ReturnType<typeof useGetPostQuery>
export type GetPostLazyQueryHookResult = ReturnType<typeof useGetPostLazyQuery>
export type GetPostQueryResult = Apollo.QueryResult<
  GetPostQuery,
  GetPostQueryVariables
>
export const GetQuestionsDocument = gql`
  query getQuestions {
    questions {
      ...QuestionInfo
    }
  }
  ${QuestionInfoFragmentDoc}
`

/**
 * __useGetQuestionsQuery__
 *
 * To run a query within a React component, call `useGetQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQuestionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetQuestionsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetQuestionsQuery,
    GetQuestionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetQuestionsQuery, GetQuestionsQueryVariables>(
    GetQuestionsDocument,
    options
  )
}
export function useGetQuestionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetQuestionsQuery,
    GetQuestionsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetQuestionsQuery, GetQuestionsQueryVariables>(
    GetQuestionsDocument,
    options
  )
}
export type GetQuestionsQueryHookResult = ReturnType<
  typeof useGetQuestionsQuery
>
export type GetQuestionsLazyQueryHookResult = ReturnType<
  typeof useGetQuestionsLazyQuery
>
export type GetQuestionsQueryResult = Apollo.QueryResult<
  GetQuestionsQuery,
  GetQuestionsQueryVariables
>
export const GetQuestionDocument = gql`
  query getQuestion($id: ID!) {
    question(id: $id) {
      ...QuestionInfo
    }
  }
  ${QuestionInfoFragmentDoc}
`

/**
 * __useGetQuestionQuery__
 *
 * To run a query within a React component, call `useGetQuestionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQuestionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQuestionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetQuestionQuery(
  baseOptions: Apollo.QueryHookOptions<
    GetQuestionQuery,
    GetQuestionQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetQuestionQuery, GetQuestionQueryVariables>(
    GetQuestionDocument,
    options
  )
}
export function useGetQuestionLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetQuestionQuery,
    GetQuestionQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetQuestionQuery, GetQuestionQueryVariables>(
    GetQuestionDocument,
    options
  )
}
export type GetQuestionQueryHookResult = ReturnType<typeof useGetQuestionQuery>
export type GetQuestionLazyQueryHookResult = ReturnType<
  typeof useGetQuestionLazyQuery
>
export type GetQuestionQueryResult = Apollo.QueryResult<
  GetQuestionQuery,
  GetQuestionQueryVariables
>
export const GetStacksDocument = gql`
  query getStacks {
    stacks {
      ...StackInfo
    }
  }
  ${StackInfoFragmentDoc}
`

/**
 * __useGetStacksQuery__
 *
 * To run a query within a React component, call `useGetStacksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStacksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStacksQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetStacksQuery(
  baseOptions?: Apollo.QueryHookOptions<GetStacksQuery, GetStacksQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetStacksQuery, GetStacksQueryVariables>(
    GetStacksDocument,
    options
  )
}
export function useGetStacksLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetStacksQuery,
    GetStacksQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetStacksQuery, GetStacksQueryVariables>(
    GetStacksDocument,
    options
  )
}
export type GetStacksQueryHookResult = ReturnType<typeof useGetStacksQuery>
export type GetStacksLazyQueryHookResult = ReturnType<
  typeof useGetStacksLazyQuery
>
export type GetStacksQueryResult = Apollo.QueryResult<
  GetStacksQuery,
  GetStacksQueryVariables
>
export const GetStackDocument = gql`
  query getStack($id: ID!) {
    stack(id: $id) {
      ...StackInfoWithTags
      usedByViewer
      usedBy {
        ...UserInfo
      }
    }
  }
  ${StackInfoWithTagsFragmentDoc}
  ${UserInfoFragmentDoc}
`

/**
 * __useGetStackQuery__
 *
 * To run a query within a React component, call `useGetStackQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStackQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStackQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetStackQuery(
  baseOptions: Apollo.QueryHookOptions<GetStackQuery, GetStackQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetStackQuery, GetStackQueryVariables>(
    GetStackDocument,
    options
  )
}
export function useGetStackLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetStackQuery,
    GetStackQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetStackQuery, GetStackQueryVariables>(
    GetStackDocument,
    options
  )
}
export type GetStackQueryHookResult = ReturnType<typeof useGetStackQuery>
export type GetStackLazyQueryHookResult = ReturnType<
  typeof useGetStackLazyQuery
>
export type GetStackQueryResult = Apollo.QueryResult<
  GetStackQuery,
  GetStackQueryVariables
>
export const GetTagsDocument = gql`
  query getTags {
    tags {
      name
    }
  }
`

/**
 * __useGetTagsQuery__
 *
 * To run a query within a React component, call `useGetTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTagsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetTagsQuery(
  baseOptions?: Apollo.QueryHookOptions<GetTagsQuery, GetTagsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetTagsQuery, GetTagsQueryVariables>(
    GetTagsDocument,
    options
  )
}
export function useGetTagsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetTagsQuery, GetTagsQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetTagsQuery, GetTagsQueryVariables>(
    GetTagsDocument,
    options
  )
}
export type GetTagsQueryHookResult = ReturnType<typeof useGetTagsQuery>
export type GetTagsLazyQueryHookResult = ReturnType<typeof useGetTagsLazyQuery>
export type GetTagsQueryResult = Apollo.QueryResult<
  GetTagsQuery,
  GetTagsQueryVariables
>
export const GetUserDocument = gql`
  query getUser($username: String!) {
    user(username: $username) {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`

/**
 * __useGetUserQuery__
 *
 * To run a query within a React component, call `useGetUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserQuery({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useGetUserQuery(
  baseOptions: Apollo.QueryHookOptions<GetUserQuery, GetUserQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    options
  )
}
export function useGetUserLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<GetUserQuery, GetUserQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<GetUserQuery, GetUserQueryVariables>(
    GetUserDocument,
    options
  )
}
export type GetUserQueryHookResult = ReturnType<typeof useGetUserQuery>
export type GetUserLazyQueryHookResult = ReturnType<typeof useGetUserLazyQuery>
export type GetUserQueryResult = Apollo.QueryResult<
  GetUserQuery,
  GetUserQueryVariables
>
export const ViewerDocument = gql`
  query viewer {
    viewer {
      ...UserInfo
    }
  }
  ${UserInfoFragmentDoc}
`

/**
 * __useViewerQuery__
 *
 * To run a query within a React component, call `useViewerQuery` and pass it any options that fit your needs.
 * When your component renders, `useViewerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useViewerQuery({
 *   variables: {
 *   },
 * });
 */
export function useViewerQuery(
  baseOptions?: Apollo.QueryHookOptions<ViewerQuery, ViewerQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<ViewerQuery, ViewerQueryVariables>(
    ViewerDocument,
    options
  )
}
export function useViewerLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<ViewerQuery, ViewerQueryVariables>
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<ViewerQuery, ViewerQueryVariables>(
    ViewerDocument,
    options
  )
}
export type ViewerQueryHookResult = ReturnType<typeof useViewerQuery>
export type ViewerLazyQueryHookResult = ReturnType<typeof useViewerLazyQuery>
export type ViewerQueryResult = Apollo.QueryResult<
  ViewerQuery,
  ViewerQueryVariables
>
export const GetViewerWithSettingsDocument = gql`
  query getViewerWithSettings {
    viewer {
      ...UserInfo
      ...UserSettings
    }
  }
  ${UserInfoFragmentDoc}
  ${UserSettingsFragmentDoc}
`

/**
 * __useGetViewerWithSettingsQuery__
 *
 * To run a query within a React component, call `useGetViewerWithSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetViewerWithSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetViewerWithSettingsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetViewerWithSettingsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >(GetViewerWithSettingsDocument, options)
}
export function useGetViewerWithSettingsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    GetViewerWithSettingsQuery,
    GetViewerWithSettingsQueryVariables
  >(GetViewerWithSettingsDocument, options)
}
export type GetViewerWithSettingsQueryHookResult = ReturnType<
  typeof useGetViewerWithSettingsQuery
>
export type GetViewerWithSettingsLazyQueryHookResult = ReturnType<
  typeof useGetViewerWithSettingsLazyQuery
>
export type GetViewerWithSettingsQueryResult = Apollo.QueryResult<
  GetViewerWithSettingsQuery,
  GetViewerWithSettingsQueryVariables
>
